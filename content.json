{"meta":{"title":"知其然，知其所以然","subtitle":"知识广度是深度的副产品","description":null,"author":"Quzard","url":"http://diudiu6.com","root":"/"},"pages":[{"title":"简介","date":"2019-01-31T11:58:05.000Z","updated":"2020-08-26T05:16:04.000Z","comments":true,"path":"about/index.html","permalink":"http://diudiu6.com/about/","excerpt":"","text":"简介本博客仅用于本人知识备份，便于以后复习重温 联系方式 Email：d2VuY2hlbmcucWl1QHNldS5lZHUuY24= 技能清单 摸鱼划水 待更新"},{"title":"所有分类","date":"2020-10-27T10:43:15.236Z","updated":"2020-08-20T08:06:31.000Z","comments":true,"path":"categories/index.html","permalink":"http://diudiu6.com/categories/","excerpt":"","text":""},{"title":"所有标签","date":"2020-10-27T10:43:15.236Z","updated":"2020-08-20T08:06:27.000Z","comments":true,"path":"tags/index.html","permalink":"http://diudiu6.com/tags/","excerpt":"","text":""}],"posts":[{"title":"面试题 08.09. 括号","slug":"面试题-08-09-括号","date":"2020-08-26T08:05:13.000Z","updated":"2020-08-26T08:17:35.000Z","comments":true,"path":"2020/08/26/面试题-08-09-括号/","link":"","permalink":"http://diudiu6.com/2020/08/26/%E9%9D%A2%E8%AF%95%E9%A2%98-08-09-%E6%8B%AC%E5%8F%B7/","excerpt":"难度（中等）括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。 说明：解集不能包含重复的子集。 例如，给出 n = 3，生成结果为： 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;]","text":"难度（中等）括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。 说明：解集不能包含重复的子集。 例如，给出 n = 3，生成结果为： 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 因为括号一定左括号先出所以 只允许出现 l == r 与 l &lt; r 的情况 12345678910111213141516class Solution &#123; vector&lt;string&gt; res;public: vector&lt;string&gt; generateParenthesis(int n) &#123; dfs(n, n, &quot;&quot;); return res; &#125; void dfs(int l, int r, string le)&#123; if(l ==0 &amp;&amp; r == 0)&#123; res.push_back(le); &#125;else&#123; if(l != 0) dfs(l - 1, r, le + &quot;(&quot;); if(l &lt; r) dfs(l, r - 1, le + &quot;)&quot;); &#125; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"http://diudiu6.com/categories/LeetCode/Medium/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/tags/LeetCode/"},{"name":"深度优先搜索 DFS","slug":"深度优先搜索-DFS","permalink":"http://diudiu6.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS/"},{"name":"回溯","slug":"回溯","permalink":"http://diudiu6.com/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"面试题 08.07. 无重复字符串的排列组合","slug":"面试题-08-07-无重复字符串的排列组合","date":"2020-08-26T07:38:21.000Z","updated":"2020-08-26T07:41:02.000Z","comments":true,"path":"2020/08/26/面试题-08-07-无重复字符串的排列组合/","link":"","permalink":"http://diudiu6.com/2020/08/26/%E9%9D%A2%E8%AF%95%E9%A2%98-08-07-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/","excerpt":"难度（中等）无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。 示例1: 12输入：S = &quot;qwe&quot;输出：[&quot;qwe&quot;, &quot;qew&quot;, &quot;wqe&quot;, &quot;weq&quot;, &quot;ewq&quot;, &quot;eqw&quot;] 示例2: 12输入：S = &quot;ab&quot;输出：[&quot;ab&quot;, &quot;ba&quot;] 提示: 字符都是英文字母。 字符串长度在[1, 9]之间。","text":"难度（中等）无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。 示例1: 12输入：S = &quot;qwe&quot;输出：[&quot;qwe&quot;, &quot;qew&quot;, &quot;wqe&quot;, &quot;weq&quot;, &quot;ewq&quot;, &quot;eqw&quot;] 示例2: 12输入：S = &quot;ab&quot;输出：[&quot;ab&quot;, &quot;ba&quot;] 提示: 字符都是英文字母。 字符串长度在[1, 9]之间。 1234567891011121314151617181920class Solution &#123;public: vector&lt;string&gt; permutation(string S) &#123; vector&lt;string&gt; res; dfs(S, res, 0); return res; &#125; void dfs(string S, vector&lt;string&gt;&amp; res,int index)&#123; if(index == S.length())&#123; res.push_back(S); &#125; else&#123; for(int i = index; i &lt; S.length(); ++i)&#123; swap(S[index], S[i]); dfs(S, res, index + 1); swap(S[index], S[i]); &#125; &#125; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"http://diudiu6.com/categories/LeetCode/Medium/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/tags/LeetCode/"},{"name":"深度优先搜索 DFS","slug":"深度优先搜索-DFS","permalink":"http://diudiu6.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS/"},{"name":"回溯","slug":"回溯","permalink":"http://diudiu6.com/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"3. 无重复字符的最长子串","slug":"3-无重复字符的最长子串","date":"2020-08-26T06:39:12.000Z","updated":"2020-08-26T06:45:01.000Z","comments":true,"path":"2020/08/26/3-无重复字符的最长子串/","link":"","permalink":"http://diudiu6.com/2020/08/26/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"难度（中等）给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。","text":"难度（中等）给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"http://diudiu6.com/categories/LeetCode/Medium/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/tags/LeetCode/"}]},{"title":"2. 两数相加","slug":"2-两数相加","date":"2020-08-26T05:17:23.000Z","updated":"2020-08-26T06:45:07.000Z","comments":true,"path":"2020/08/26/2-两数相加/","link":"","permalink":"http://diudiu6.com/2020/08/26/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"难度（中等）给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807","text":"难度（中等）给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; auto* res = new ListNode(0); int sum = 0; int plus = 0; bool FIRST = 0; ListNode* current = res; while (l1 || l2)&#123; int x = (l1) ? l1 -&gt; val : 0; int y = (l2) ? l2 -&gt; val : 0; sum = x + y + plus; plus = sum / 10; current-&gt; next = new ListNode(sum % 10); current = current -&gt;next; if(l1) l1 = l1 -&gt; next; if(l2) l2 = l2 -&gt; next; &#125; if(plus) current-&gt; next = new ListNode(plus % 10); if(res)&#123; current = res; res = current -&gt; next; delete current; &#125; return res; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"http://diudiu6.com/categories/LeetCode/Medium/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/tags/LeetCode/"},{"name":"初等数学","slug":"初等数学","permalink":"http://diudiu6.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"17. 电话号码的字母组合","slug":"17-电话号码的字母组合","date":"2020-08-26T01:53:58.000Z","updated":"2020-08-26T07:40:21.000Z","comments":true,"path":"2020/08/26/17-电话号码的字母组合/","link":"","permalink":"http://diudiu6.com/2020/08/26/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","excerpt":"难度（中等）给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。","text":"难度（中等）给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 用哈希表 代替 switch12345678910unordered_map&lt;char, string&gt; phoneMap&#123; &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;, &#123;&#x27;3&#x27;, &quot;def&quot;&#125;, &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;, &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;, &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;, &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;, &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;, &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125;&#125;; xiao_ben_zhu 对回溯的理解回溯本质是暴力搜索，在问题的解空间树中，用 DFS 的方式，从根节点出发搜索整个解空间。 如果要找出所有的解，则要搜索整个子树，如果只用找出一个解，则搜到一个解就可以结束搜索。 类似「找出所有可能的组合」的问题，适合回溯算法。 做回溯类题目，要明确三个关键点： 选择决定了你每个节点有哪些分支，可以帮助你构建出解的空间树。约束条件用来剪枝，剪去不满足约束条件的子树，避免无效的搜索。目标决定了你何时捕获解，或者剪去得不到解的子树，提前回溯。 作者：xiao_ben_zhu链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/shou-hua-tu-jie-liang-chong-jie-fa-dfshui-su-bfsya/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; combinations; if (digits.empty()) return combinations; unordered_map&lt;char, string&gt; phoneMap&#123; &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;, &#123;&#x27;3&#x27;, &quot;def&quot;&#125;, &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;, &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;, &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;, &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;, &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;, &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125; &#125;; string combination; dfs(combinations, phoneMap, digits, combination, 0); return combinations; &#125; void dfs(vector&lt;string&gt;&amp; combinations, const unordered_map&lt;char, string&gt;&amp; phoneMap,const string&amp; digits, string&amp; combination, int index)&#123; if(index == digits.length())&#123; combinations.push_back(combination); &#125;else&#123; string words = phoneMap.at(digits[index]); for(auto word:words)&#123; combination.push_back(word); dfs(combinations, phoneMap, digits, combination, index + 1); combination.pop_back(); &#125; &#125; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"http://diudiu6.com/categories/LeetCode/Medium/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/tags/LeetCode/"},{"name":"hash","slug":"hash","permalink":"http://diudiu6.com/tags/hash/"},{"name":"深度优先搜索 DFS","slug":"深度优先搜索-DFS","permalink":"http://diudiu6.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS/"},{"name":"回溯","slug":"回溯","permalink":"http://diudiu6.com/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"111. 二叉树的最小深度","slug":"111-二叉树的最小深度","date":"2020-08-21T09:21:10.000Z","updated":"2020-08-26T06:47:38.000Z","comments":true,"path":"2020/08/21/111-二叉树的最小深度/","link":"","permalink":"http://diudiu6.com/2020/08/21/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/","excerpt":"难度（简单）给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 返回它的最小深度 2.","text":"难度（简单）给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 返回它的最小深度 2. 1234567891011121314151617181920212223//深度优先搜索class Solution1 &#123;public: int minDepth(TreeNode *root) &#123; if (root == nullptr) &#123; return 0; &#125; if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123; return 1; &#125; int min_depth = INT_MAX; if (root-&gt;left != nullptr) &#123; min_depth = min(minDepth(root-&gt;left), min_depth); &#125; if (root-&gt;right != nullptr) &#123; min_depth = min(minDepth(root-&gt;right), min_depth); &#125; return min_depth + 1; &#125;&#125;; 12345678910111213141516171819202122232425262728//广度优先搜索class Solution2 &#123;public: int minDepth(TreeNode *root) &#123; if (root == nullptr) &#123; return 0; &#125; queue&lt;pair&lt;TreeNode *, int&gt; &gt; que; que.emplace(root, 1); while (!que.empty()) &#123; TreeNode *node = que.front().first; int depth = que.front().second; que.pop(); if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123; return depth; &#125; if (node-&gt;left != nullptr) &#123; que.emplace(node-&gt;left, depth + 1); &#125; if (node-&gt;right != nullptr) &#123; que.emplace(node-&gt;right, depth + 1); &#125; &#125; return 0; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"http://diudiu6.com/categories/LeetCode/Easy/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/tags/LeetCode/"},{"name":"递归","slug":"递归","permalink":"http://diudiu6.com/tags/%E9%80%92%E5%BD%92/"},{"name":"深度优先搜索 DFS","slug":"深度优先搜索-DFS","permalink":"http://diudiu6.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS/"},{"name":"广度优先搜索 BFS","slug":"广度优先搜索-BFS","permalink":"http://diudiu6.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS/"}]},{"title":"LeetCode——1. 两数之和","slug":"1-两数之和","date":"2020-08-20T03:36:26.000Z","updated":"2020-08-26T06:45:15.000Z","comments":true,"path":"2020/08/20/1-两数之和/","link":"","permalink":"http://diudiu6.com/2020/08/20/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"难度（简单）给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]","text":"难度（简单）给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 该题可用hash表 unordered_map 来解决 以 i 从头遍历 nums，每次判断 target - nums[i]是否在 unordered_map 中，若无则将 nums[i] 加入unordered_map，并将其与坐标i匹配 遍历直到找到答案才结束 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; map; vector&lt;int&gt; res (-1,-1); for(int i = 0; i &lt; nums.size(); ++i)&#123; if(map.count(target - nums[i]) &gt; 0)&#123; res[0] = map[target - nums[i]]; res[1] = i; return res; &#125; map[nums[i]] = i; &#125; return res; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"http://diudiu6.com/categories/LeetCode/Easy/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/tags/LeetCode/"},{"name":"hash","slug":"hash","permalink":"http://diudiu6.com/tags/hash/"}]},{"title":"类继承","slug":"类继承","date":"2020-05-09T07:18:30.000Z","updated":"2020-05-09T12:59:01.000Z","comments":true,"path":"2020/05/09/类继承/","link":"","permalink":"http://diudiu6.com/2020/05/09/%E7%B1%BB%E7%BB%A7%E6%89%BF/","excerpt":"类继承 本章内容包括： is-a 关系的继承。 如何以公有方式从一个类派生出另一个类。 保护访问。 构造函数成员初始化列表。 向上和向下强制转换。 虚成员函数。 早期（静态）联编与晚期（动态）联编。 抽象基类。 纯虚函数。 何时及如何使用公有继承。","text":"类继承 本章内容包括： is-a 关系的继承。 如何以公有方式从一个类派生出另一个类。 保护访问。 构造函数成员初始化列表。 向上和向下强制转换。 虚成员函数。 早期（静态）联编与晚期（动态）联编。 抽象基类。 纯虚函数。 何时及如何使用公有继承。 类继承——它能够从已有的类派生出新的类，而派生类继承了原有类（称为基类）的特征，包括方法。 可以在原有类的基础上添加功能。例如，对于数组类，可以添加数学运算。 可以给类添加数据。例如，对于字符串类可以派生出一个类，并添加指定字符串显示颜色的数据成员。 可以修改类方法的行为。例如，对于代表提供给飞机乘客的服务的passenger类，可以派生出提供给头等舱服务的FirstPassenger类。 13.1 一个简单的基类12345678910111213141516171819202122232425class TableTennisPlayer&#123;private: string firstname; string lastname; bool hasTable;public: TableTennisPlayer (const string &amp; fn = &quot;none&quot;, const string &amp; ln = &quot;none&quot;, bool ht = false);&#125;;/*这将首先为firstname调用string的默认构造函数，再调用string的赋值运算符将firstname设置为fn*/TableTennisPlayer::TableTennisPlayer (const string &amp; fn, const string &amp; ln, bool ht) &#123; firstname = fn; lastname = ln; hasTable = ht; &#125;/*初始化列表语法初始化列表语法可减少一个步骤，它直接使用string的复制构造函数将firstname 初始化为fnTableTennisPlayer::TableTennisPlayer (const string &amp; fn, const string &amp; ln, bool ht) : firstname(fn), lastname(ln), hasTable(ht) &#123;&#125;*/ 给一个类派生出另一个类时，原始类称为基类，继承类成为派生类。 公有派生(public) 派生类对象包含基类对象。使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分(private)也将成为派生类的一部分，但只能通过基类的公有和保护方法访问 派生类对象存储了基类的数据成员（派生类继承了积累的实现） 派生类对象可以使用基类的方法（派生类继承了基类的接口） 派生类需要自己的构造函数。 派生类可以根据需要添加额外的数据成员和成员函数。 构造函数必须给新成员(如果有的话)和继承的成员提供数据。 13.1.2构造函数：访问权限的考虑 派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。派生类不能直接设置继承的成员，而必须使用基类的公有方法来访问私有的基类成员。具体地说，派生类构造函数必须使用基类构造函数。 创建派生类对象时，程序首先创建基类对象。 从概念上说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。C+ +使用成员初始化列表语法来完成这种工作。 非构造函数不能使用成员初始化列表语法，但派生类方法可以调用公有的基类方法 例如，派生类构造函数在初始化基类私有数据时，采用的是成员初始化列表语法 123456// RatedPlayer 继承于 TableTennisPlayer// class RatedPlayer : public TableTennisPlayerRatedPlayer: : RatedPlayer (unsigned int r, const string &amp; fn, const string &amp; 1n, bool ht) : TableTennisPlayer(fn， 1n, ht)&#123; rating = r;&#125; 如果省略成员初始化列表（不调用基类构造函数），程序将使用默认的基类构造函数 有关派生类构造函数的要点如下: 首先创建基类对象 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数，根据继承顺序初始化，而不是初始化列表中的顺序 派生类构造函数应初始化派生类新增的数据成员。根据声明顺序初始化，而不是初始化列表中的顺序 释放对象的顺序与创建对象的顺序相反，首先执行派生类的析构函数，然后自动调用基类的析构函数。 派生类并不能直接访问基类的私有数据，必须使用基类的公有方法才能访问这些数据 再次总结 创建派生类对象时，程序首先调用基类构造函数 基类构造函数负责初始化继承的数据成员 然后再调用派生类构造函数。 派生类构造函数主要用于初始化新增的数据成员。 派生类的构造函数总是调用一个基类构造函数。 可以使用初始化器列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。 派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。 虛基类外(参见第14章)，类只能将值传递回相邻的基类，但后者可以使用相同的机制将信息传递给相邻的基类，依此类推。如果没有在成员初始化列表中提供基类构造函数，程序将使用默认的基类构造函数。成员初始化列表只能用于构造函数。 13.1.3派生类和基类之间的特殊关系 派生类对象可以使用基类的方法，条件是不是私有的 基类指针可以在不进行显式类型转换的情况下指向派生类对象 基类引用可以在不进行显示类型转换的情况下引用派生类对象 基类指针或引用只能用于调用基类方法，因此,不能来调用派生类的方法。 不可以将基类对象和地址赋给派生类引用和指针 1234567891011class A&#123;&#125;;class B:public A&#123;&#125;;B temp_1(1,2,3);A temp_2(temp_1);/*要初始化temp_2,匹配的构造函数的原型如下:A (const B&amp;);类定义中没有这样的构造函数，但存在隐式复制构造函数A(const A&amp;);形参是基类引用，因此他可以引用派生类*/ 13.2继承： is-a关系公有继承 13.3多态公有继承实现多态公有继承方法 在派生类中重新定义基类的方法 使用虚方法virtual 如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。 如果没有使用关键字virtual,程序将根据引用类型或指针类型选择方法 123456789101112131415class A&#123;public: void print();&#125;;class B:public A&#123;public: void print();&#125;;A temp_1();B temp_2();A* P_1 = &amp; temp_1;P_1 -&gt; print(); // 调用 A::print()A* P_2 = &amp; temp_2;P_2 -&gt; print(); // 调用 A::print() 如果使用了virtual,程序将根据引用或指针指向的对象的类型来选择方法。 123456789101112131415class A&#123;public: virtual void print();&#125;;class B:public A&#123;public: virtual void print();&#125;;A temp_1();B temp_2();A* P_1 = &amp; temp_1;P_1 -&gt; print(); // 调用 A::print()A* P_2 = &amp; temp_2;P_2 -&gt; print(); // 调用 B::print() 方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。然而，在派生类声明中使用关键字virual来指出哪此函数县虎函数也不失为一个好办法。（派生类不一定要加virtual，基类一定要；virtual只需要在原型中写出，但定义中不需要写，和friend一样） 只要派生类的函数与基类的同原型（函数返回类型、函数名和形参列表），自动转为虚函数，不需要声明virtual，如果不同的话就叫作函数重载了；虚函数只能是类中成员函数且不能是静态，有隐藏的this指针 基类声明虚析构函数。这样做是为了确保释放派生对象时，按正确的顺序调用析构函数。 使用delete释放由new分配的对象时，如果析构函数不是虚的，则将只调用对应于指针类型的析构函数。如果析构函数是虚的，将调用相应对象类型的析构函数。因此，如果基类指针指向的是派生类对象，将调用派生类 的析构函数，然后自动调用基类的析构函数。因此，使用虚析构函数可以确保正确的析构函数序列被调用 注意:如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例。 13.4.1指针和引用类型的兼容性 在C++中，动态联编与通过指针和引用调用方法相关，从某种程度上说，这是由继承控制的。 将派生类引用或指针转换为基类引用或指针被称为向上强制转换(upcasting),这使公有继承不需要进行显式类型转换。该规则是is-a 关系的一部分。 BrassPlus 对象都是Brass对象，因为它继承了Brass对象 相反的过程——将 基类指针或引用转换为派生类指针或引用——称 为向下强制转换。如果不使用显式类型转换，则向下强制转换是不允许的。原因是is-a 关系通常是不可逆的。派生类可以新 1234567891011121314151617class Employee&#123;private: char nane[401;public: void show nane();&#125;;class Singer : public Employee&#123;public: void range();&#125;;Employee veep;Singer trala;Employee pe= &amp;trala; // 允许向上隐式类型转换Singer* ps = (Singer *) &amp;veep; // 必须向下显式类型转换pe-&gt;show nane(); // 向上转换带来安全操作，因为Singer是Employee(每个singer都继承姓名)ps-&gt;range(); //向下转换可能带来不安全的操作，因为Employee并不是Singer(Eaployee没有有range()方法) 如果要在派生类中重新定义基类的方法，则将它设置为虚方法;否则，设置为非虚方法。 13.4.3有关虚函数注意事项1. 构造函数构造函数不能是虚函数。创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后，派生类的构造函数将使用基类的一个构造函数，这种顺序不同于继承机制。因此，派生类不继承基类的构造函数，所以将类构造函数声明为虚的没什么意义。 2. 析构函数析构函数应当是虚函数，除非类不用做基类。例如，假设Employee是基类，Singer 是派生类,并添加一个char *成员，该成员指向由new分配的内存。当Singer对象过期时，必须调用~Singer( )析构函数来释放内存。 12Employee * pe = new Singer; delete pe; 如果使用默认的静态联编，delete 语句将调用~Employee( )析构函数。这将释放由Singer 对象中的Employee部分指向的内存，但不会释放新的类成员指向的内存。 如果析构函数是虚的，则上述代码将先调用Singer析构函数释放由Singer组件指向的内存,然后,调用Employee()析构函数来释放由Employee组件指向的内存。这意味着，即使基类不需要显式析构函数提供服务，也不应依赖于默认析构函数，而应提供虚析构函数，即使它不执行任何操作: virtual ~BaseClass() { } 给类定义一个虚析构函数并非错误，即使这个类不用做基类:这只是一个效率方面的问题。通常应给基类提供一个虚析构函数，即使它并不需要析构函数。 3. 友元 友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。可以通过让友元函数使用虚成员函数来解决。 4. 没有重新定义 如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的。 5. 重新定义将隐藏方法 12345678910111213141516 class Dwelling&#123; public: virtual void showperks(int a) const; &#125;; class Hovel : public Dweling&#123; public: virtual void showperks() const; &#125;; Hovel trump; trump.showperks() ;// valid trump.showperks(5) ;// invalid trump.Dwelling::showperks(5) ;// valid /* 新定义将showperks( )定义为一个不接受任何参数的函数。重新定义不会生成函数的两个重载版本，而是隐藏了接受一个int参数的基类版本。*/ 重新定义继承的方法并不是重载。如果在派生类中重新定义函数，将不是使用相同的函数特征标覆盖基类声明，而是隐藏同名的基类方法，不管参数特征标如何。 如果派生类的函数与基类的函数同名，但是参数不同。此时，无论有无virtual关键字，积累的函数将被隐藏（注意别与重载混淆）。 如果派生类的函数与积累的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。 这引出了两条经验规则: 第一,如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针(这种例外是新出现的)。这种特性被称为返回类型协变(covariance of return type)，因为允许返回类型随类类型的变化而变化 这种例外只适用于返回值，而不适用于参数。 第二，如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。 如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们。注意，如果不需要修改，则新定义可只调用基类版本 1void Hovel: : showperks() const &#123;Dwelling::showperks() ;&#125; 13.5访问控制: protected12345class test&#123;protected: int n; int get_n()&#123;&#125;&#125; 关键字protected 与private 相似，在类外只能用公有类成员来访问protected部分中的类成员。 private 和protected之间的区别只有在基类派生的类中才会表现出来。 派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。 对于外部世界来说, 保护成员的行为 ≈ 私有成员的行为 对于派生类来说， 保护成员的行为 ≈ 公有成员的行为 最好对类数据成员采用私有访问控制，不要使用保护访问控制 同时通过基类方法使派生类能够访问基类数据。然而，对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数。 13.6抽象基类（不一定要虚函数） 纯虚函数C+ +通过使用纯虚函数(pure vitual function)提供未实现的函数。纯虚函数声明的结尾处为=0 1234567891011class BaseEllipse&#123;private : double x; double y; public: BaseEllipse(double x0 = 0, double y0 = 0) : x(x0) ,y(y0) &#123;&#125; virtual ~BaseEllipse() &#123;&#125; void Move(int nx, ny) &#123; X= nx; y= ny; &#125; virtual double Area() const = 0; &#125; 当类声明中包含纯虚函数时，则不能创建该类的对象。包含纯虚函数的类只用作基类。 要成为真正的ABC（抽象基类）,必须至少包含一个纯虚函数。即原型中的=0使虚函数成为纯虚函数，比如这里的方法Area()没有定义。 C++甚至允许纯虚函数有定义。例如，也许所有的基类方法都与Move()一样，可以在基类中进行定义，但您仍需要将这个类声明为抽象的。在这种情况下，可以将原型声明为虚的: 1void Move(int nx，ny) = 0; 这将使基类成为抽象的，但您仍可以在实现文件中提供方法的定义: 1void BaseEllipse: :Move(int nx，ny) &#123; x = nx;y= ny; &#125; 总之，在原型中使用=0指出类是一个抽象基类，在类中可以不定义该函数。 13.7 继承和动态内存分配1234567891011121314151617181920212223class baseDMA&#123;private: char * label; int rating;public: baseDMA(const char * l = &quot;null&quot;, int r = 0); baseDMA(const baseDMA &amp; rs); virtual ~baseDMA(); baseDMA &amp; operator=(const baseDMA &amp; rs); friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const baseDMA &amp; rs);&#125;;class lacksDMA :public baseDMA&#123;private: enum &#123; COL_LEN = 40&#125;; char color[COL_LEN];public: lacksDMA(const char * c = &quot;blank&quot;, const char * l = &quot;null&quot;, int r = 0); lacksDMA(const char * c, const baseDMA &amp; rs); friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const lacksDMA &amp; rs);&#125;; 复制类成员或继承的类组件时，则是使用该类的复制构造函数完成的。所以，lacksDMA类的默认复制构造函数将使用显式baseDMA复制构造函数baseDMA (const baseDMA &amp; rs)来复制lacksDMA对象的baseDMA部分。 对于赋值来说，也是如此。类的默认赋值运算符将自动使用基类的赋值运算符baseDMA &amp; operator= (const baseDMA &amp; rs) 来对基类组件进行赋值。 类的默认析构函数会将自动使用基类的析构函数~baseDMA()来对类成员或继承的类组件析构。故其自身的职责是对派生类构造函数执行工作的部分进行清理。 1234567891011121314class hasDMA :public baseDMA&#123;private: char * style;public: hasDMA(const char * s = &quot;none&quot;, const char * l = &quot;null&quot;, int r = 0); hasDMA(const char * s, const baseDMA &amp; rs); hasDMA(const hasDMA &amp; hs); ~hasDMA(); hasDMA &amp; operator=(const hasDMA &amp; rs); friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const hasDMA &amp; rs);&#125;; 复制构造函数1234567/*hasDMA复制构造函数只能访问hasDMA的数据，因此它必须调用baseDMA复制构造函数来处理共享的baseDMA数据:*/hasDMA: : hasDMA (const hasDMA &amp; hs) : baseDMA (hs)&#123;style = new char [std: :strlen (hs.style) + 1];std: :strcpy(style，hs.style) ;&#125; 需要注意的一点是， 成员初始化列表将一个hasDMA引用传递给baseDMA构造函数。 没有参数类型为hasDMA引用的baseDMA构造函数，也不需要这样的构造函数。 因为复制构造函数baseDMA有一个baseDMA引用参数，而基类引用可以指向派生类型。 因此，baseDMA 复制构造函数将使用 const hasDMA &amp; hs参数的baseDMA部分来构造新对象的baseDMA部分。 赋值运算符重载12345678910hasDMA &amp; hasDMA: : operator= (const hasDMA &amp; hs)&#123; if (this == &amp;hs&#125; return *this; baseDMA: :operator=(hs); // 通过使用函数表示法，而不是运算符表示法，可以使用作用域解析运算法 delete [] style; style = new char [std: :strlen(hs.sty1e) + 1] ; std: :strcpy (style，hs.style) ; return this;&#125; 友元12345std: :ostream &amp; operator&lt;&lt; (std: :ostream &amp; os，const hasDMA &amp; hs)&#123; os &lt;&lt; (const baseDMA &amp;) hs; os &lt;&lt; &quot;Style: ”&lt;&lt; hs.style &lt;&lt; endl; return os;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://diudiu6.com/categories/C/"},{"name":"C++ primer plus","slug":"C/C-primer-plus","permalink":"http://diudiu6.com/categories/C/C-primer-plus/"},{"name":"第十三章","slug":"C/C-primer-plus/第十三章","permalink":"http://diudiu6.com/categories/C/C-primer-plus/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"}],"tags":[{"name":"learning","slug":"learning","permalink":"http://diudiu6.com/tags/learning/"},{"name":"C++ primer plus","slug":"C-primer-plus","permalink":"http://diudiu6.com/tags/C-primer-plus/"}]},{"title":"符合python风格的对象","slug":"符合python风格的对象","date":"2019-05-22T02:23:52.000Z","updated":"2019-05-22T04:49:29.000Z","comments":true,"path":"2019/05/22/符合python风格的对象/","link":"","permalink":"http://diudiu6.com/2019/05/22/%E7%AC%A6%E5%90%88python%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%AF%B9%E8%B1%A1/","excerpt":"得益于 Python 数据模型，自定义类型的行为可以像内置类型那样自然。实现如自然的行为，靠的不是继承，而是鸭子类型（duck typing）：我们只需按照预定行为实对象所需的方法即可。","text":"得益于 Python 数据模型，自定义类型的行为可以像内置类型那样自然。实现如自然的行为，靠的不是继承，而是鸭子类型（duck typing）：我们只需按照预定行为实对象所需的方法即可。 1.特殊方法repr() 以便于开发者理解的方式返回对象的字符串表示形式。str() 以便于用户理解的方式返回对象的字符串表示形式。 bytes() 调用它获取对象的字节序列表示形式 __format__ 方法会被内置的 format() 函数和 str.format() 方法调用 使用特殊的格式代码显示对象的字符串表示形式 print 函数会调用 str 函数 bytes 函数会调用 __bytes__ 方法，生成实例的二进制表示形式。 abs 函数会调用 __abs__ 方法，返回实例的模。 bool 函数会调用 __bool__ 方法，如果实例的模为零，返回 False，否则返回 True。 1234567891011121314151617181920212223from array import arrayimport mathclass Vector2d: typecode = &#x27;d&#x27; # typecode 是类属性，在 Vector2d 实例和字节序列之间转换时使用。 def __init__(self, x, y): self.x = float(x) # 在 __init__ 方法中把 x 和 y 转换成浮点数，尽早捕获错误，以防调用 Vector2d 函数时传入不当参数。 self.y = float(y) def __iter__(self): return (i for i in (self.x, self.y)) # 定义 __iter__ 方法，把 Vector2d 实例变成可迭代的对象，这样才能拆包（例如，x, y = my_vector）。这个方法的实现方式很简单，直接调用生成器表达式一个接一个产出分量。 def __repr__(self): class_name = type(self).__name__ return &#x27;&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)&#x27;.format(class_name, *self) #__repr__ 方法使用 &#123;!r&#125; 获取各个分量的表示形式，然后插值，构成一个字符串；因为 Vector2d 实例是可迭代的对象，所以 *self 会把 x 和 y 分量提供给 format 函数。 def __str__(self): return str(tuple(self)) # 从可迭代的 Vector2d 实例中可以轻松地得到一个元组，显示为一个有序对。 def __bytes__(self): return (bytes([ord(self.typecode)]) + # 为了生成字节序列，我们把 typecode 转换成字节序列，然后…… bytes(array(self.typecode, self))) # ……迭代 Vector2d 实例，得到一个数组，再把数组转换成字节序列。 def __eq__(self, other): return tuple(self) == tuple(other) # 为了快速比较所有分量，在操作数中构建元组。对 Vector2d 实例来说，可以这样做，不过仍有问题。参见下面的警告。 def __abs__(self): return math.hypot(self.x, self.y) #模是 x 和 y 分量构成的直角三角形的斜边长。 def __bool__(self): return bool(abs(self)) # __bool__ 方法使用 abs(self) 计算模，然后把结果转换成布尔值，因此，0.0 是False，非零值是 True。 2.格式化显示内置的 format() 函数和 str.format() 方法把各个类型的格式化方式委托给相应的.__format__(format_spec) 方法。format_spec 是格式说明符，他是： format(my_obj, format_spec) 的第二个参数，或者 str.format() 方法的格式字符串，{} 里代换字段中冒号后面的部分 1234567&gt;&gt;&gt; brl = 1/2.43 # BRL到USD的货币兑换比价&gt;&gt;&gt; brl0.4115226337448559&gt;&gt;&gt; format(brl, &#x27;0.4f&#x27;) # 格式说明符是 &#x27;0.4f&#x27;。&#x27;0.4115&#x27;&gt;&gt;&gt; &#x27;1 BRL = &#123;rate:0.2f&#125; USD&#x27;.format(rate=brl) # 格式说明符是 &#x27;0.2f&#x27;。代换字段中的 &#x27;rate&#x27; 子串是字段名称，与格式说明符无关，但是它决定把 .format() 的哪个参数传给代换字段。&#x27;1 BRL = 0.41 USD&#x27; ‘{0.mass:5.3e}’ 这样的格式字符串其实包含两部分，冒号左边的 ‘0.mass’ 在代换字段句法中是字段名，冒号后面的 ‘5.3e’ 是格式说明符 格式说明符使用的表示法叫格式规范微语言 格式描述12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455fill 可以是任意字符，默认为空格。align 仅当指定最小宽度时有效。&lt; 左对齐（默认选项）&gt; 右对齐= 仅对数字有效；将填充字符放到符号与数字间，例如 +0001234^ 居中对齐sign 仅对数字有效+ 所有数字均带有符号- 仅负数带有符号（默认选项） 即空格；正数前面带空格，负数前面带符号&#x27;#&#x27; 只对整数有效自动在二进制、八进制、十六进制数值前添加对应的 0b、0o、 0x。&#x27;,&#x27; 自动在每三个数字之间添加 , 分隔符。width 十进制数字，定义最小宽度。如果未指定，则由内容的宽度来决定。如果没有指定对齐方式（align），那么可以在 width 前面添加一个0来实现自动填充0，等价于 fill 设为 0 并且 align 设为 =。precision 用于确定浮点数的精度，或字符串的最大长度。不可用于整型数值。type 确定参数类型，默认为 s ，即字符串。整数输出类型：b：以二进制格式输出c：将整数转换成对应的 unicode 字符d：以十进制输出（默认选项）o：以八进制输出x：以十六进制小写输出X：以十六进制大写输出n：与 d 相同，但使用当前环境的分隔符来分隔每3位数字十进制浮点数输出类型：e：指数标记；使用科学计数法输出，用e来表示指数部分，默认 precision 为6E：与 e 相同，但使用大写 E 来表示指数部分f：以定点形式输出数值，默认 precision 为6F：与 f 相同g：通用格式；对于给定的 precision p &gt;= 1，取数值的p位有效数字，并以定点或科学计数法输出（默认选项）G：通用格式；与 g 相同，当数值过大时使用 E 来表示指数部分n：与 g 相同，但使用当前环境的分隔符来分隔每3位数字%：百分比标记；使用百分比的形式输出数值，同时设定 f 标记 格式规范微语言是可扩展的，因为各个类可以自行决定如何解释 format_spec 参数 如果类没有定义 format 方法，从 object 继承的方法会返回 str(my_object)。 然而，如果传入格式说明符，object.format 方法会抛出 TypeError： 示例 Vector2d.format 方法，第 1 版 1234# 在Vector2d类中定义def __format__(self, fmt_spec=&#x27;&#x27;): components = (format(c, fmt_spec) for c in self) # 使用内置的 format 函数把 fmt_spec 应用到向量的各个分量上，构建一个可迭代的格式化字符串。 return &#x27;(&#123;&#125;, &#123;&#125;)&#x27;.format(*components) # 把格式化字符串代入公式 &#x27;(x, y)&#x27; 中 3.可散列的Vector2d目前 Vector2d 实例是不可散列的，因此不能放入集合（set）中 为了把 Vector2d 实例变成可散列的，必须使用 hash 方法（还需要 __eq__ 方法，前面已经实现了）此外，还要让向量不可变 1234567891011121314151617class Vector2d: typecode = &#x27;d&#x27; def __init__(self, x, y): self.__x = float(x) #使用两个前导下划线（尾部没有下划线，或者有一个下划线），把属性标记为私有 self.__y = float(y) @property # @property 装饰器把读值方法标记为特性。 def x(self): #读值方法与公开属性同名，都是 x return self.__x #直接返回 self.__x @property # 以同样的方式处理 y 特性 def y(self): return self.__y def __iter__(self): return (i for i in (self.x, self.y)) # 需要读取 x 和 y 分量的方法可以保持不变，通过 self.x 和 self.y 读取公开特性，而不必读取私有属性，因此上述代码清单省略了这个类的其他代码。 def __hash__(self): return hash(self.x) ^ hash(self.y) def __eq__(self, other): return tuple(self) == tuple(other) 要想创建可散列的类型，不一定要实现特性，也不一定要保护实例属性。只需正确地实现 hash 和 eq 方法即可。但是，实例的散列值绝不应该变化，因此我们借机提到了只读特性。 4.Python的私有属性和“受保护的”属性现在，你创建了 Dog 类的子类：Beagle。，如果以 __mood 的形式（两个前导下划线，尾部没有或最多有一个下划线）命名实例属性，Python 会把属性名存入实例的 __dict__ 属性中，而且会在前面加上一个下划线和类名。因此，对 Dog 类来说，__mood 会变成 _Dog__mood；这个语言特性叫名称改写 但是，只要知道改写私有属性名的机制，任何人都能直接读取私有属性——这对调试和序列化倒是有用。此外，只要编写 v1._Vector__x = 7 这样的代码，就能轻松地为 Vector2d 实例的私有分量直接赋值。 Python 解释器不会对使用单个下划线（如self._x)的属性名做特殊处理，不过这是很多 Python 程序员严格遵守的约定，他们不会在类外部访问这种属性。 （注：像遵守使用全大写字母编写常量） Python 文档的某些角落把使用一个下划线前缀标记的属性称为“受保护的”属性。 使用self._x 这种形式保护属性的做法很常见，但是很少有人把这种属性叫作“受保护的”属性。有些人甚至将其称为“私有”属性。 5.使用 __slots__ 类属性节省空间默认情况下，Python 在各个实例中名为 dict 的字典里存储实例属性。为了使用底层的散列表提升访问速度，字典会消耗大量内存。如果要处理数百万个属性不多的实例，通过 __slots__ 类属性，能节省大量内存，方法是让解释器在元组中存储实例属性，而不用字典。 123class Vector2d: __slots__ = (&#x27;__x&#x27;, &#x27;__y&#x27;) typecode = &#x27;d&#x27; 在类中定义 __slots__ 属性的目的是告诉解释器：“这个类中的所有实例属性都在这儿了！”这样，Python 会在各个实例中使用类似元组的结构存储实例变量，从而避免使用消耗内存的 __dict__ 属性。如果有数百万个实例同时活动，这样做能节省大量内存。 如果要处理数百万个数值对象，应该使用 NumPy 数组（参见 2.9.3 节）。NumPy 数组能高效使用内存，而且提供了高度优化的数值处理函数，其中很多都一次操作整个数组。 如果把 ‘__dict__‘ 这个名称添加到__slots__ 中，实例会在元组中保存各个实例的属性，此外还支持动态创建属性，这些属性存储在常规的 __dict__ 中。当然，把 ‘__dict__‘ 添加到 __slots__ 中可能完全违背了初衷，这取决于各个实例的静态属性和动态属性的数量及其用法。 在类中定义 _slots__ 属性之后，实例不能再有 _slots 中所列名称之外的其他属性。这只是一个副作用，不是 __slots__ 存在的真正原因。不要使用__slots__ 属性禁止类的用户新增实例属性。 __slots__ 是用于优化的，不是为了约束程序员 为了让对象支持弱引用（参见 8.6 节），必须有这个属性。用户定义的类中默认就有 __weakref__ 属性。可是，如果类中定义了 __slots__ 属性，而且想把实例作为弱引用的目标，那么要把’__weakref__‘ 添加到 __slots__ 中 如果使用得当，__slots__ 能显著节省内存，不过有几点要注意。 每个子类都要定义 __slots__ 属性，因为解释器会忽略继承的 __slots__ 属性。 实例只能拥有 __slots__ 中列出的属性，除非把 ‘__slots__‘ 加入 __slots__ 中（这样做就失去了节省内存的功效）。 如果不把 ‘__weakref__‘ 加入 __slots__，实例就不能作为弱引用的目标。","categories":[{"name":"Python","slug":"Python","permalink":"http://diudiu6.com/categories/Python/"},{"name":"流畅的python","slug":"Python/流畅的python","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"第九章","slug":"Python/流畅的python/第九章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E4%B9%9D%E7%AB%A0/"}],"tags":[{"name":"流畅的python","slug":"流畅的python","permalink":"http://diudiu6.com/tags/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"learning","slug":"learning","permalink":"http://diudiu6.com/tags/learning/"}]},{"title":"CNN原理基本学习","slug":"CNN原理基本学习","date":"2019-05-21T11:42:07.000Z","updated":"2020-08-26T05:49:05.000Z","comments":true,"path":"2019/05/21/CNN原理基本学习/","link":"","permalink":"http://diudiu6.com/2019/05/21/CNN%E5%8E%9F%E7%90%86%E5%9F%BA%E6%9C%AC%E5%AD%A6%E4%B9%A0/","excerpt":"1.基本架构一个CNN网络一般都是卷积、池化、卷积、池化，…，全连接的模式。 最简单的就是 卷积层（特征提取）→激活函数（为了加入非线性因素）→池化层（采样层，用于压缩数据）→全连接层（用于分类）→反向传播算法，前馈神经网络等调整卷积核参数","text":"1.基本架构一个CNN网络一般都是卷积、池化、卷积、池化，…，全连接的模式。 最简单的就是 卷积层（特征提取）→激活函数（为了加入非线性因素）→池化层（采样层，用于压缩数据）→全连接层（用于分类）→反向传播算法，前馈神经网络等调整卷积核参数 简单的神经元 一个三层神经网络结构 上图中最左边的原始输入信息称之为输入层，最右边的神经元称之为输出层（上图中输出层只有一个神经元），中间的叫隐藏层。 2.卷积层用一张动态卷积图来说明下卷积的原理 卷积公式：$$\\displaystyle \\int^{\\infty}_{-\\infty}{f(τ)g(x-τ)dτ}$$g(x)——卷积核 物理意义：系统的某一时刻的输出是由多个输入同时作用（叠加）而成的 例子：$$\\frac{\\partial f}{\\partial x} = f(x+1)-f(x)$$ $$\\frac{\\partial^2 f}{\\partial x^2} = f(x+1)+f(x-1)-2f(x)$$ $$\\overrightarrow{\\nabla}^2f=\\frac{\\partial^2 f}{\\partial x^2}+\\frac{\\partial^2 f}{\\partial y^2}=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)$$ $$\\overrightarrow{\\nabla}^2f——拉普拉斯算子，强调图像中的灰度突变，可用于突出图像边缘$$ $$\\downarrow\\downarrow$$ $$\\left[ \\begin{matrix} 0 &amp;1 &amp;0 \\1 &amp; -4 &amp;1 \\ 0 &amp; 1 &amp; 0\\end{matrix} \\right]$$ $$\\downarrow\\downarrow$$ 作为g(x)与原图像f(x)卷积，可以用来锐化图像 从这些案例中可以看出 原始图像通过与卷积核的数学运算，可以提取出图像的某些指定特征（features) 不同卷积核，提取的特征也是不一样的 即使提取的特征一样，不同的卷积核，效果也不一样 而CNN实际上也就是一个不断提取特征，进行特征选择，然后进行分类的过程，卷积在CNN里，就是充当前排步兵，首先对原始图像进行特征提取 上动图中可以看出，一个5×5的原图与一个3×3的核（图中深红色部分）进行卷积，得到一个3×3的特征图。（此时，stride=2，padding= 1） stride，一般称为步长。表示卷积核在图片上移动的格数。stride=1时，代表每次移动一格；stride=2时，则每次移动两格。有如下公式， $$OutputSize=\\frac{PictureSize−Kernel}{SizeStride}+1$$ padding，即外围补0用以扩展图片。此时，$$OutputSize=\\frac{PictureSize+2×Padding−KernelSize}{SizeStride}+1$$ 一个3 * 3的source经过一个3 * 3的卷积核，特征映射成了一个1 * 1的特征值 卷积核代表了对应的权重 卷积核和图像进行点乘就代表卷积核里的权重单独对应到相应位置进行作用$$\\displaystyle \\sum^{}_{i}{w_ix_i=output}$$ 在CNN中卷积核的权重局部参数共享，通过反向传播来不断优化更新自己权重。 3.激活函数由于线性函数具有可加性和齐次性 任意线性函数连接都可以等价为一个单一线性函数 所以线性神经网络没法解决非线性问题 我们就需要把线性神经网络，转成非线性的 我们从最简单的神经网络 Y = W×X +B入手，然后变成最简单的非线性神经网络Y = W×X×X+B 这是一个普通Y = X×X 的表达式 Y = W×X×X+B 经过一系列运算（理想的） 我们得到了如下： 变成曲线后，好像可以把这两类区分开诶 我们需要算出输出误差error (output Y - target Y) 来更新权值 如果我们的神经网络函数是线性的，那么它的导数就是个常数，意味着梯度和X 无关了，也就是和输入无关了 我们在做反向传播的时候，梯度的改变也变成常数，和输入的改变X(delta(x)) 无关了 常见的激活函数 sigmoid 只会输出正数，以及靠近0的输出变化率最大，tanh和sigmoid不同的是，tanh输出可以是负数，ReLu是输入只能大于0,如果你输入含有负数，ReLu就不适合，如果你的输入是图片格式，ReLu就挺常用的。 其实卷积层的输出，是特征提取后的，特征值越大，说明特征越明显，特征值小的就可以用激活函数滤去了。我对激活函数的作用理解差不多就是这样。 取其精华去其糟粕。 4.池化层 池化可以将一幅大的图像缩小，同时又保留其中的重要信息 它就是将输入图像进行缩小，减少像素信息，只保留重要信息 通常情况下，池化都是2×2大小，比如对于max-pooling来说，就是取输入图像中2×2大小的块中的最大值，作为结果的像素值，相当于将原始图像缩小了4倍(注：同理，对于average-pooling来说，就是取2×2大小块的平均值作为结果的像素值) 因为最大池化（max-pooling）保留了每一个小块内的最大值，所以它相当于保留了这一块最佳的匹配结果（因为值越接近1表示匹配越好） 这也就意味着它不会具体关注窗口内到底是哪一个地方匹配了，而只关注是不是有某个地方匹配上了 这也就能够看出，CNN能够发现图像中是否具有某种特征，而不用在意到底在哪里具有这种特征 通过加入池化层，可以很大程度上减少计算量，降低机器负载。 5.全连接层 全连接层也能够有很多个，如下： 【综合上述所有结构】这一整个过程，从前到后，被称作”前向传播“，得到一组输出，然后通过反向传播来不断纠正错误，进行学习。 6.反向传播此处数学原理可以参见：深度学习 —— 反向传播理论推导. 反向传播可分为四部分，分别是前向传导、损失函数、后向传导，以及权重更新 在前向传导中，选择一张训练图像数组并让它通过整个网络 在第一个训练样例上，由于所有的权重或者过滤器值都是随机初始化的，输出可能会是 [.1 .1 .1 .1 .1 .1 .1 .1 .1 .1]，即一个不偏向任何数字的输出 损失函数有许多种定义方法，常见的一种是 MSE （均方误差）$$E_{total}=\\sum\\frac{1}{2}(target-output)^2$$我们需要找出是哪部分输入（例子中的权重）直接导致了网络的损失（或错误） 这是一个 dL/dW 的数学等式，W 是特定层级的权重。我们接下来要做的是在网络中进行后向传导，测定出是哪部分权重导致了最大的损失，寻找调整方法并减少损失。一旦计算出该导数，将进行最后一步也就是权重更新。所有的过滤器的权重将会更新，以便它们顺着梯度方向改变。$$w = w_i-\\eta\\frac{dL}{dW}$$ $$w = 权重\\quad w_i=初始权重\\quad\\eta=学习速率$$ 学习速率是一个由程序员决定的参数。高学习速率意味着权重更新的动作更大，因此可能该模式将花费更少的时间收敛到最优权重。然而，学习速率过高会导致跳动过大，不够准确以致于达不到最优点。 对于每个特征像素和投票权重，将其上下调整一下，看看错误如何变化我们需要设置的参数 卷积层 卷积层数目 卷积层大小 池化层 窗口大小 补零数 全连接层 全连接层数目 样本","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://diudiu6.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"CNN","slug":"深度学习/CNN","permalink":"http://diudiu6.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CNN/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://diudiu6.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"CNN","slug":"CNN","permalink":"http://diudiu6.com/tags/CNN/"}]},{"title":"Python使用xpath爬取数据返回空列表解决方案","slug":"xpath定位失败原因","date":"2019-03-28T05:27:29.000Z","updated":"2020-08-26T05:50:00.000Z","comments":true,"path":"2019/03/28/xpath定位失败原因/","link":"","permalink":"http://diudiu6.com/2019/03/28/xpath%E5%AE%9A%E4%BD%8D%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0/","excerpt":"最近学了下xpath定位来爬虫 刚刚试了下学校的srtp网站，发现爬取的数据返回是空列表","text":"最近学了下xpath定位来爬虫 刚刚试了下学校的srtp网站，发现爬取的数据返回是空列表 直接获得的xpath是 //*[@id=”table1”]/tbody/tr[16]/td[7] 通过查询资料获得，是tbody问题造成的。浏览器会对html文本进行一定的规范化，所以会自动在路径中加入tbody，导致读取失败，在此处直接在路径中去除tbody即可。 也就是 //*[@id=”table1”]/tr[16]/td[7] 即可 源码 123456789101112131415161718# coding: utf-8__author__ = &quot;2019/3/27 22:02&quot;__time__ = &quot;Quzard&quot;import requestsfrom lxml import etreeheaders = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36&#x27; &#x27;AppleWebKit/537.36 (KHTML, like Gecko)&#x27; &#x27; Chrome/63.0.3239.84 Safari/537.36&#x27;, &#x27;Referer&#x27;: &#x27;http://www.baidu.com&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;&#125;url = &quot;http://10.1.30.98:8080/srtp2/USerPages/SRTP/Report3.aspx?Code=04016613&quot;data = requests.get(url, headers=headers)data = data.texts = etree.HTML(data)print(s.xpath(&quot;//*[@id=&#x27;table1&#x27;]/tr[last()-1]/td[last()]/text()&quot;)[0])","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://diudiu6.com/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"xpath","slug":"xpath","permalink":"http://diudiu6.com/tags/xpath/"}]},{"title":"TensorFlow介绍","slug":"TensorFlow教程","date":"2019-02-05T10:29:26.000Z","updated":"2020-08-26T05:49:28.000Z","comments":true,"path":"2019/02/05/TensorFlow教程/","link":"","permalink":"http://diudiu6.com/2019/02/05/TensorFlow%E6%95%99%E7%A8%8B/","excerpt":"1.关于TensorFlowTensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。","text":"1.关于TensorFlowTensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。 1.1什么是数据流图（Data Flow Graph） 数据流图用“结点”（nodes）和“线”(edges)的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点/输出（push out）的终点，或者是读取/写入持久变量（persistent variable）的终点。“线”表示“节点”之间的输入/输出关系。这些数据“线”可以输运“size可动态调整”的多维数据数组，即“张量”（tensor）。张量从图中流过的直观图像是这个工具取名为“Tensorflow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。 1.2TensorFLow 六大特性1.高度的灵活性—-提供很多的工具让你来构建图,也可以在tf基础上写上层库,对tf操作进行组合,还可以动手丰富底层操作,自己添加tf内容2.真正的可移植性—-tf在CPU和GPU上运行，可以运行在台式机、服务器、手机移动设备,Android,ios都可以,平台之间转移可以不用改3.将科研和产品联系在一起—-tf可以免去很大的代码重写工作,帮助科研工作者提高科研产出率4.自动求微分—-用户只需要定义预测模型的结构，将这个结构和目标函数结合在一起，并添加数据,tf将自动为你计算相关的微分导数5.多语言支持—-官方文档中写明,目前有python/c++使用界面,还鼓励开发者开发其他语言6.性能最优化—-给予了线程、队列、异步操作等以最佳支持,tf让你可以将你手边硬件的计算潜能全部发挥出来。你可以自由地将tf图中的计算元素分配到不同设备上,tf可以帮你管理好这些不同副本","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://diudiu6.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"TensorFlow","slug":"深度学习/TensorFlow","permalink":"http://diudiu6.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://diudiu6.com/tags/TensorFlow/"}]},{"title":"对象引用、可变性和垃圾回收","slug":"对象引用、可变性和垃圾回收","date":"2019-02-04T05:10:57.000Z","updated":"2020-08-26T05:43:44.000Z","comments":true,"path":"2019/02/04/对象引用、可变性和垃圾回收/","link":"","permalink":"http://diudiu6.com/2019/02/04/%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%AF%E5%8F%98%E6%80%A7%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","excerpt":"名称不是对象，而是单独的东西。 Python 的变量：变量是标注，而不是盒子。 Python 变量类似于 Java 中的引用式变量，因此最好把它们理解为附加在对象上的标注","text":"名称不是对象，而是单独的东西。 Python 的变量：变量是标注，而不是盒子。 Python 变量类似于 Java 中的引用式变量，因此最好把它们理解为附加在对象上的标注 对引用式变量来说，说把变量分配给对向更合理 Python 中的赋值语句，始终先读右边，对象在右边创建或获取，在此之后左边的变量才会绑定到对象上，这就像为对象贴上标注。 每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变；你可以把标识理解为对象在内存中的地址。is 运算符比较两个对象的标识；id() 函数返回对象标识的整数表示。ID 一定是唯一的数值标注，而且在对象的生命周期中绝不会变。 12345alex = &#123;&#x27;name&#x27;: &#x27;Charles L. Dodgson&#x27;, &#x27;born&#x27;: 1832, &#x27;balance&#x27;: 950&#125;alex == charles&gt;&gt;&gt; Truealex is not charlesTrue 在==和is之间选择== 运算符比较两个对象的值（对象中保存的数据），而 is 比较对象的标识（id号）。 元组的相对不可变性 元组与多数 Python 集合（列表、字典、集，等等）一样，保存的是对象的引用。 即便元组本身不可变，元素依然可变 元组的不可变性其实是指 tuple 数据结构的物理内容（即保存的引用）不可变，与引用的对象无关 str、bytes 和 array.array 等单一类型序列是扁平的，它们保存的不是引用，而是在连续的内存中保存数据本身（字符、字节和数字） 12345678910111213t1 = (1, 2, [30, 40]) t2 = (1, 2, [30, 40]) t1 == t2 &gt;&gt;&gt;Trueid(t1[-1]) &gt;&gt;&gt;4302515784t1[-1].append(99) t1&gt;&gt;&gt;(1, 2, [30, 40, 99])id(t1[-1]) &gt;&gt;&gt;4302515784t1 == t2 &gt;&gt;&gt;False 默认做浅复制复制列表（或多数内置的可变集合）最简单的方式是使用内置的类型构造方法 对列表和其他可变序列来说，还能使用简洁的 l2 = l1[:]语句创建副本 12345678&gt;&gt;&gt; l1 = [3, [55, 44], (7, 8, 9)]&gt;&gt;&gt; l2 = list(l1) &gt;&gt;&gt; l2&gt;&gt;&gt; [3, [55, 44], (7, 8, 9)]&gt;&gt;&gt; l2 == l1 &gt;&gt;&gt; True&gt;&gt;&gt; l2 is l1 &gt;&gt;&gt; False 然而，构造方法或 [:] 做的是浅复制（即复制了最外层容器，副本中的元素是源容器中元素的引用） 如果所有元素都是不可变的，那么这样没有问题，还能节省内存 但是，如果有可变的元素，可能就会导致意想不到的问题 12345678910l1 = [3, [66, 55, 44], (7, 8, 9)]l2 = list(l1) # l2 是 l1 的浅复制副本l1.append(100) # 把 100 追加到 l1 中，对 l2 没有影响。l1[1].remove(55) # 把内部列表 l1[1] 中的 55 删除。这对 l2 有影响，因为l2[1] 绑定的列表与 l1[1]是同一个。print(&#x27;l1:&#x27;, l1)print(&#x27;l2:&#x27;, l2)l2[1] += [33, 22] # 对可变的对象来说，如 l2[1] 引用的列表，+= 运算符就地修改列表。这次修改在l1[1] 中也有体现，因为它是 l2[1] 的别名。l2[2] += (10, 11) # 对元组来说，+= 运算符创建一个新元组，然后重新绑定给变量 l2[2]。这等同于l2[2] = l2[2] + (10, 11)。现在，l1 和 l2 中最后位置上的元组不是同一个对象。print(&#x27;l1:&#x27;, l1)print(&#x27;l2:&#x27;, l2) 对元组来说，+= 运算符创建一个新元组 为任意对象做深复制和浅复制copy 模块提供的 deepcopy 和 copy 函数能为任意对象做深复制和浅复制12345678910111213&gt;&gt;&gt; import copy&gt;&gt;&gt; bus1 = Bus([&#x27;Alice&#x27;, &#x27;Bill&#x27;, &#x27;Claire&#x27;, &#x27;David&#x27;])&gt;&gt;&gt; bus2 = copy.copy(bus1)&gt;&gt;&gt; bus3 = copy.deepcopy(bus1)&gt;&gt;&gt; id(bus1), id(bus2), id(bus3)(4301498296, 4301499416, 4301499752) # 使用 copy 和 deepcopy，创建 3 个不同的 Bus 实例。&gt;&gt;&gt; bus1.drop(&#x27;Bill&#x27;)&gt;&gt;&gt; bus2.passengers[&#x27;Alice&#x27;, &#x27;Claire&#x27;, &#x27;David&#x27;] # bus1 中的 &#x27;Bill&#x27; 下车后，bus2 中也没有他了。&gt;&gt;&gt; id(bus1.passengers), id(bus2.passengers), id(bus3.passengers)(4302658568, 4302658568, 4302657800) # 审查 passengers 属性后发现，bus1 和 bus2 共享同一个列表对象，因为 bus2 是bus1 的浅复制副本。&gt;&gt;&gt; bus3.passengers[&#x27;Alice&#x27;, &#x27;Bill&#x27;, &#x27;Claire&#x27;, &#x27;David&#x27;] # bus3 是 bus1 的深复制副本，因此它的 passengers 属性指代另一个列表。 一般来说，深复制不是件简单的事。如果对象有循环引用，那么这个朴素的算法会进入无限循环。deepcopy 函数会记住已经复制的对象，因此能优雅地处理循环引用 函数的参数作为引用时 Python 唯一支持的参数传递模式是共享传参（call by sharing） 共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。 函数可能会修改作为参数传入的可变对象（比如列表），但是无法修改那些对象的标识（即不能把一个对象替换成另一个对象） 不要使用可变类型作为参数的默认值默认值在定义函数时计算（通常在加载模块时），因此默认值变成了函数对象的属性。因此，如果默认值是可变对象，而且修改了它的值，那么后续的函数调用都会受到影响。 如果定义的函数接收可变参数，应该谨慎考虑调用方是否期望修改传入的参数del和垃圾回收 del 语句删除名称，而不是对象 del 命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时 重新绑定也可能会导致对象的引用数量归零，导致对象被销毁 有时需要引用对象，而不让对象存在的时间超过所需时间。这经常用在缓存中。 弱引用不会增加对象的引用数量。引用的目标对象称为所指对象（referent） 弱引用不会妨碍所指对象被当作垃圾回收。 弱引用是可调用的对象，返回的是被引用的对象；如果所指对象不存在了，返回 None 1234567891011121314&gt;&gt;&gt; import weakref&gt;&gt;&gt; a_set = &#123;0, 1&#125;&gt;&gt;&gt; wref = weakref.ref(a_set) # 创建弱引用对象 wref，下一行审查它。&gt;&gt;&gt; wref&lt;weakref at 0x100637598; to &#x27;set&#x27; at 0x100636748&gt;&gt;&gt;&gt; wref() # 调用 wref() 返回的是被引用的对象，&#123;0, 1&#125;。因为这是控制台会话，所以 &#123;0, 1&#125;会绑定给 _ 变量。&#123;0, 1&#125;&gt;&gt;&gt; a_set = &#123;2, 3, 4&#125; # a_set 不再指代 &#123;0, 1&#125; 集合，因此集合的引用数量减少了。但是 _ 变量仍然指代它。&gt;&gt;&gt; wref() # 调用 wref() 依旧返回 &#123;0, 1&#125;。&#123;0, 1&#125;&gt;&gt;&gt; wref() is None # 计算这个表达式时，&#123;0, 1&#125; 存在，因此 wref() 不是 None。但是，随后 _ 绑定到结果值 False。现在 &#123;0, 1&#125; 没有强引用了。False&gt;&gt;&gt; wref() is None # 因为 &#123;0, 1&#125; 对象不存在了，所以 wref() 返回 None。True 12345678910111213141516&gt;&gt;&gt; import weakref&gt;&gt;&gt; stock = weakref.WeakValueDictionary() # stock 是 WeakValueDictionary 实例。&gt;&gt;&gt; catalog = [Cheese(&#x27;Red Leicester&#x27;), Cheese(&#x27;Tilsit&#x27;),... Cheese(&#x27;Brie&#x27;), Cheese(&#x27;Parmesan&#x27;)]...&gt;&gt;&gt; for cheese in catalog:... stock[cheese.kind] = cheese # stock 把奶酪的名称映射到 catalog 中 Cheese 实例的弱引用上。...&gt;&gt;&gt; sorted(stock.keys())[&#x27;Brie&#x27;, &#x27;Parmesan&#x27;, &#x27;Red Leicester&#x27;, &#x27;Tilsit&#x27;] # stock 是完整的。&gt;&gt;&gt; del catalog&gt;&gt;&gt; sorted(stock.keys())[&#x27;Parmesan&#x27;] # 删除 catalog 之后，stock 中的大多数奶酪都不见了，这是 WeakValueDictionary的预期行为。为什么不是全部呢？&gt;&gt;&gt; del cheese&gt;&gt;&gt; sorted(stock.keys())[] 临时变量引用了对象，这可能会导致该变量的存在时间比预期长。通常，这对局部变量来说不是问题，因为它们在函数返回时会被销毁。 *不是每个 Python 对象都可以作为弱引用的目标（或称所指对象）。基本的 list 和 dict实例不能作为所指对象，但是它们的子类可以轻松地解决这个问题** set 实例可以作为所指对象 变量保存的是引用，这一点对 Python 编程有很多实际的影响 简单的赋值不创建副本。 对 += 或 *= 所做的增量赋值来说，如果左边的变量绑定的是不可变对象，会创建新对象；如果是可变对象，会就地修改。 为现有的变量赋予新值，不会修改之前绑定的变量。这叫重新绑定：现在变量绑定了其他对象。如果变量是之前那个对象的最后一个引用，对象会被当作垃圾回收。 函数的参数以别名的形式传递，这意味着，函数可能会修改通过参数传入的可变对象。这一行为无法避免，除非在本地创建副本，或者使用不可变对象（例如，传入元组，而不传入列表）。 使用可变类型作为函数参数的默认值有危险，因为如果就地修改了参数，默认值也就变了，这会影响以后使用默认值的调用。 可以在自己的类中定义 __ eq __ 方法，决定 == 如何比较实例。如果不覆盖 __ eq __ 方法，那么从 object 继承的方法比较对象的 ID","categories":[{"name":"Python","slug":"Python","permalink":"http://diudiu6.com/categories/Python/"},{"name":"流畅的python","slug":"Python/流畅的python","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"第八章","slug":"Python/流畅的python/第八章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E5%85%AB%E7%AB%A0/"}],"tags":[{"name":"流畅的python","slug":"流畅的python","permalink":"http://diudiu6.com/tags/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"learning","slug":"learning","permalink":"http://diudiu6.com/tags/learning/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2019-02-04T03:43:45.000Z","updated":"2019-05-21T09:50:32.000Z","comments":true,"path":"2019/02/04/Markdown语法/","link":"","permalink":"http://diudiu6.com/2019/02/04/Markdown%E8%AF%AD%E6%B3%95/","excerpt":"Markdown 是什么 Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML） 文档 这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。","text":"Markdown 是什么 Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML） 文档 这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 基本语法标题一个到多个#，然后空格，最后是文字。 123456# 标题H1## 标题H2### 标题H3#### 标题H4##### 标题H5###### 标题H6 以上文本转换后如下： 标题H1标题H2标题H3标题H4标题H5标题H6 列表无序列表提示符（*或者-或者+），然后是空格，最后是文字。敲击回车的时候，会自动出现新提示符。想要结束列表，连续敲两下回车即可。 123+ A + B + C 以上文本转换后得到： A B C 有序列表先是数字，然后是.，再然后是空格，最后是文字。敲击回车的时候，会自动出现新序号。想要结束列表，连续敲两下回车即可。 1231. a 2. b 3. b a b b 代码代码块和语法高亮使用一对三个反引号来包含多行代码： 1234​``` int a = 0; a++;​``` 效果： 12int a = 0;a++; 在上面的语法基础上，在第一个三个反引号 之后添加代码的语言名称，即可实现语法高亮。 12345​```python int a = 0; a++;​```1234 效果： 12int a = 0;a++; 行内代码可以通过两个反引号（Tab 键上方、数字 1 左侧的那个按键）插入行内代码。反引号 int a = 100; 反引号 转换后是： int a = 100; 分隔线在一行中使用三个或更多的-或者*或者_ ，然后换行。---（回车） 效果如下： 强调斜体用两个*把要强调的内容包含起来，则表现为斜体。*我是斜体*效果如下： 我是斜体 粗体用两个**把要强调的内容包含起来，则表现为粗体。**我是粗体**效果如下： 我是粗体 引用单行引用在行首使用 &gt;符号，就可以将其后的内容标记为引用。&gt;春风得意马蹄疾，一日看尽长安花 效果如下： 春风得意马蹄疾，一日看尽长安花 多行引用如果仅在第一行使用 &gt;， 后面相邻的行即使省略 &gt;，也会变成引用内容。&gt;在天愿作比翼鸟，在地愿为连理枝。 天长地久有时尽，此恨绵绵无绝期。 以上文本被转换为： 在天愿作比翼鸟，在地愿为连理枝。天长地久有时尽，此恨绵绵无绝期。 要结束引用，在引用的末尾连续敲两个回车即可。 嵌套的引用用多个&gt;就可以表示嵌套的引用。&gt;子曰&gt;&gt;学而时习之，不亦说乎？有朋自远方来，不亦乐乎？ 效果如下： 子曰 学而时习之，不亦说乎？有朋自远方来，不亦乐乎？ 引用中可以使用其他语法引用的内容也可以使用其他语法，比如标题、列表、强调等。 12345678910&gt;1. 我是列表&gt;2. 我是列表&gt;3. 我是列表&gt; &gt;*我是斜体*&gt;**我是粗体**&gt;&gt; int a = 0;&gt; int b = 1;&gt; int c = a + b; 12345678910 效果如下： 我是列表 我是列表 我是列表 我是斜体我是粗体 int a = 0; int b = 1; int c = a + b; 12345678910 超链接行内式格式为：[链接文字](地址 &#39;标题&#39;)注：地址与标题之间有一个空格。 例如：[百度首页](https://www.baidu.com/ &quot;跳转到百度首页&quot;) 效果如下： 百度首页 当你把鼠标停留在链接名称上，则会显示出标题。 注：在不需要的情况下，标题可以省略。 参考式参考式超链接一般用在学术论文上，或者某个链接在文章中多处被引用的情况，这样便于对链接统一管理。 参考式链接的写法相当于把行内式拆分成两部分，并通过一个链接标记来连接两部分。 语法说明：参考式链接分为两部分：首先写[链接文字][链接标记] 然后在文本的任意位置写[链接标记]:地址 &quot;标题&quot; 如果链接文字本身可以作链接标记，你也可以把上面两行分别写为：[链接文字][][链接文字]:地址 &quot;标题&quot; 例如：我经常去的几个网站是[GitHub][1]，[知乎][2]，[简书][3]。 123[1]:https://github.com &quot;github.com&quot;[2]:https://www.zhihu.com &quot;zhihu.com&quot; [3]:http://www.jianshu.com &quot;jianshu.com&quot; 效果： 我经常去的几个网站是GitHub，知乎，简书。 如果把链接文字本身作为链接标记，则写为：我经常去的几个网站是[GitHub][]，[知乎][]，[简书][]。 [GitHub]:https://github.com &quot;github.com&quot;[知乎]:https://www.zhihu.com &quot;zhihu.com&quot;[简书]:http://www.jianshu.com &quot;jianshu.com&quot; 效果：我经常去的几个网站是GitHub，知乎，简书。 图片插入图片的语法和插入超链接的语法基本一致，只是在最前面多一个!。也分为行内式和参考式两种。行内式： ![炮姐](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549263234828&amp;di=4a344f759b9ceb725d0e741500b7d0b3&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201503%2F29%2F20150329004520_mL3HU.jpeg &quot;炮姐萌吗&quot;) 参考式1：![炮姐][4] 1[4]:https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549263234828&amp;di=4a344f759b9ceb725d0e741500b7d0b3&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201503%2F29%2F20150329004520_mL3HU.jpeg &quot;参考式1——炮姐萌吗&quot; 参考式2（把链接文字本身作为链接标记）：![炮姐][] 1[炮姐]:https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549263234828&amp;di=4a344f759b9ceb725d0e741500b7d0b3&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201503%2F29%2F20150329004520_mL3HU.jpeg &quot;参考式2——炮姐萌吗&quot; 转义字符Markdown可以利用反斜线\\来插入一些在语法中有其它意义的符号。例如：想把星号加在文字两侧（但不是斜体），你可以在星号的前面加上反斜线：\\*literal asterisks\\*效果：literal asterisks Markdown 支持在下面这些符号前面加上反斜线来插入普通的符号： \\ 反斜线` 反引号 星号_ 下划线{} 大括号[] 方括号() 括号#井号 加号 減号. 英文句点! 感叹号 扩展语法删除线用两个~~把文字包起来。 12~~我是删除线~~1 效果：我是删除线 表格基本格式使用| 来分隔不同的单元格，使用-来分隔表头和其他行。name | age---- | ---Leslie| 12Mike | 32 效果： name age Leslie 12 Mike 32 指定对齐方式在表头下方的分隔线----标记中加入:，即可指定对齐方式。 :---代表左对齐；:---: 代表居中对齐；---:代表右对齐。 1234left | center | right :---:| :---- |------:| aaaaaaaaa| bbbbbbbbbbbb |ccccccccccccccccccccc || a | b | c | 效果 left center right aaaaaaaaa bbbbbbbbbbbb a b 如果不使用对齐标记，单元格中的内容默认左对齐，表头单元格中的内容默认居中对齐（MarkdownPad就是这样，不同的实现可能会有不同的效果）。 表格内换行可以用&lt;br&gt;表示换行。 1234Name | Lucky Number---- | ---Leslie| 2&lt;br&gt;7Mike | 3&lt;br&gt;5&lt;br&gt;8 效果： Name Lucky Number Leslie 27 Mike 358 表格内嵌套同引用一样，表格的内容也可以使用其他语法，比如公式、引用、行内代码等。 12345Name | *abcdef*---- |-----Leslie| `int a=18;`Mike | $\\log_28$Ann| &gt;青霄有路终须到，金榜无名誓不归 效果： Name abcdef Leslie int a=18; Mike $\\log_28$ Ann &gt;青霄有路终须到，金榜无名誓不归 内嵌HTML下划线Markdown 并无下划线的原生语法，因为会和链接的默认样式产生混淆。如果你非要给文字加个下划线，也有办法。用&lt;u&gt;和&lt;/u&gt;把文字括起来，则有下划线效果。 &lt;u&gt;我有下划线，可是我不是链接&lt;/u&gt;效果： 我有下划线，可是我不是链接 字体、字号、颜色例1：指定字体&lt;font face=&quot;隶书&quot;&gt; 我是隶书 &lt;/font&gt;效果： 我是隶书 例2：指定字号size的取值范围：从 1 到 7 ，浏览器默认值是 3。&lt;font size=5 &gt; 我的size = 5 &lt;/font&gt; 效果： 我的size = 5 例3：指定颜色&lt;font color=GreenYellow&gt;我的color=GreenYellow &lt;/font&gt; 效果：我的color=GreenYellow 背景色Markdown本身不支持背景色设置，需要采用内置html的方式实现。借助 table，tr， td 等表格标签的 bgcolor 属性来实现背景色功能。 举例1：&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt; 背景色是橙色 &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;效果： 背景色是橙色 举例2：&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=green&gt; &lt;font size = 4 color=yellow&gt; Hello World &lt;/font&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;效果： Hello World 注脚语法说明：在需要添加注脚的文字后加上脚注名字,称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 [^注脚名字] [^注脚名字]: emoji表情符号emoji表情使用:EMOJICODE:的格式，详细列表可见https://www.webpagefx.com/tools/emoji-cheat-sheet/ 当然现在很多markdown工具或者网站都不支持。 语法： :kissing_smiling_eyes:","categories":[{"name":"page 搭建","slug":"page-搭建","permalink":"http://diudiu6.com/categories/page-%E6%90%AD%E5%BB%BA/"},{"name":"Markdown语法","slug":"page-搭建/Markdown语法","permalink":"http://diudiu6.com/categories/page-%E6%90%AD%E5%BB%BA/Markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Markdown语法","slug":"Markdown语法","permalink":"http://diudiu6.com/tags/Markdown%E8%AF%AD%E6%B3%95/"}]},{"title":"Windows虚拟桌面也挺好用","slug":"Windows虚拟桌面也挺好用","date":"2019-02-03T09:02:45.000Z","updated":"2020-08-26T05:49:46.000Z","comments":true,"path":"2019/02/03/Windows虚拟桌面也挺好用/","link":"","permalink":"http://diudiu6.com/2019/02/03/Windows%E8%99%9A%E6%8B%9F%E6%A1%8C%E9%9D%A2%E4%B9%9F%E6%8C%BA%E5%A5%BD%E7%94%A8/","excerpt":"「虚拟桌面」能干什么？「虚拟桌面」是一种窗口任务的虚拟分组方式，每个桌面就是一个分组。每创建一个虚拟桌面，就好像重新打开了一个Windows，你能够在一个全新的桌面环境下工作或学习。而之前桌面里打开的软件任务窗口，依然保留在那里，你可以随时切换回原来的桌面。 虚拟桌面的目的在于对不同类型的应用窗口进行分类，使之同时保持前台显示而不致互相干扰。通俗的理解就是：把 N 台显示器塞进同一个显示器里头。 用途 以把所有「开发程序」的编辑器开在一个虚拟桌面里 把「参考网站」的浏览器开在一个桌面里 把微信之类的「聊天应用」开在另一个桌面里","text":"「虚拟桌面」能干什么？「虚拟桌面」是一种窗口任务的虚拟分组方式，每个桌面就是一个分组。每创建一个虚拟桌面，就好像重新打开了一个Windows，你能够在一个全新的桌面环境下工作或学习。而之前桌面里打开的软件任务窗口，依然保留在那里，你可以随时切换回原来的桌面。 虚拟桌面的目的在于对不同类型的应用窗口进行分类，使之同时保持前台显示而不致互相干扰。通俗的理解就是：把 N 台显示器塞进同一个显示器里头。 用途 以把所有「开发程序」的编辑器开在一个虚拟桌面里 把「参考网站」的浏览器开在一个桌面里 把微信之类的「聊天应用」开在另一个桌面里 快捷键入口Win 键+Tab：打开「任务视图」，选择切换/创建 「虚拟桌面」。（很多人至今还在用 Alt + Tab， 虽然 Windows Vista 起就能通过 Win + Tab执行「花哨可视化」任务切换功能） Win键+CTRL+D：创建新的虚拟桌面（几乎没人知道，没人用）。 Win键+CTRL+F4：删除当前虚拟桌面（几乎没人知道，没人用）。 Win键+CTRL+左键：切换到相邻左侧的虚拟桌面。 Win键+CTRL+右键：切换到相邻右侧的虚拟桌面。（这两个快捷键很实用，相当于传说中的 Boss 键了，老板来了，立刻从「放羊」切换到「工作」桌面） 清洁的任务栏窗口多了，任务栏显得拥挤不堪，即便合并了同类应用窗口也难以补救。 而虚拟桌面让任务栏的程序标签也跟着分门别类，换言之各个虚拟桌面只会显示其前台对应的程序标签，任务栏不会再密密麻麻。 根据需求来调整要用好虚拟桌面，需明确其目的是分类窗口以减少窗口堆砌带来的不便，则窗口的分类自然要依据窗口需求来进行。 举个例子，日常文字类工作往往需要保持三类应用窗口开启： 即时通讯类应用（如微信、QQ） 文字处理类应用（如 Office 全家桶、笔记类应用） 资料检索类应用（如浏览器、PDF 阅读器） 比如即时通讯应用放在第一（左边）桌面，资料检索应用放在第三（右边）桌面，这么做符合左右切换桌面的逻辑。 窗口拖入虚拟桌面 「虚拟桌面」的进阶用法鼠标按键切换：这是一个最得心应手的方案，但需要你有一个拥有可自定义侧边按键的鼠标，在相应的鼠标控制软件中将侧边左键映射到快捷键「Ctrl + Win + ←」，右键反之。","categories":[{"name":"使用技巧","slug":"使用技巧","permalink":"http://diudiu6.com/categories/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://diudiu6.com/tags/Windows/"}]},{"title":"函数装饰器和闭包","slug":"函数装饰器和闭包","date":"2019-02-02T02:41:29.000Z","updated":"2020-08-26T05:45:11.000Z","comments":true,"path":"2019/02/02/函数装饰器和闭包/","link":"","permalink":"http://diudiu6.com/2019/02/02/%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/","excerpt":"函数装饰器函数装饰器用于在源码中“标记”函数，以某种方式增强函数的行为。这是一项强大的功能，但是若想掌握，必须理解闭包。 装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。 装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。","text":"函数装饰器函数装饰器用于在源码中“标记”函数，以某种方式增强函数的行为。这是一项强大的功能，但是若想掌握，必须理解闭包。 装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。 装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。 假如有个名为 decorate 的装饰器： 1234567def deco(func): def inner(): print(&#x27;running inner()&#x27;) return inner@decoratedef target(): print(&#x27;running target()&#x27;) 上述代码的效果与下述写法一样： 123456789101112131415161718192021222324def deco(func): def inner(): print(&#x27;running inner()&#x27;) return innerdef target(): print(&#x27;running target()&#x27;)target = decorate(target)```两种写法的最终结果一样：上述两个代码片段执行完毕后得到的 target 不一定是原来那个 target 函数，而是 decorate(target) 返回的函数，也就是inner的引用。​```Python&gt;&gt;&gt;def deco(func):&gt;&gt;&gt; func()&gt;&gt;&gt; def inner():&gt;&gt;&gt; print(&#x27;running inner()&#x27;)&gt;&gt;&gt; return inner # deco 返回 inner 函数对象。&gt;&gt;&gt;@decorate&gt;&gt;&gt;def target(): # 使用 deco 装饰 target。&gt;&gt;&gt; print(&#x27;running target()&#x27;)&gt;&gt;&gt;target() # 调用被装饰的 target 其实会运行 inner。&gt;&gt;&gt;running target()&gt;&gt;&gt;running inner()&gt;&gt;&gt; target # 审查对象，发现 target 现在是 inner 的引用。&lt;function deco.&lt;locals&gt;.inner at 0x10063b598&gt; 装饰器可以像常规的可调用对象那样调用，其参数是另一个函数。有时，这样做更方便，尤其是做元编程（在运行时改变程序的行为）时。综上，装饰器的一大特性是，能把被装饰的函数替换成其他函数。第二个特性是，装饰器在加载模块时立即执行。 123456789101112131415161718192021registry = [] # registry 保存被 @register 装饰的函数引用。def register(func): # register 的参数是一个函数。 print(&#x27;running register(%s)&#x27; % func) # 为了演示，显示被装饰的函数。 registry.append(func) #把 func 存入 registry。 return func # 返回 func：必须返回函数；这里返回的函数与通过参数传入的一样。@register # f1 和 f2 被 @register 装饰。def f1(): print(&#x27;running f1()&#x27;)@registerdef f2(): print(&#x27;running f2()&#x27;)def f3(): # f3 没有装饰。 print(&#x27;running f3()&#x27;)def main(): # main 显示 registry，然后调用 f1()、f2() 和 f3()。 print(&#x27;running main()&#x27;) print(&#x27;registry -&gt;&#x27;, registry) f1() f2() f3()if __name__==&#x27;__main__&#x27;: main() # 只有把 registration.py 当作脚本运行时才调用 main()。 12345678910111213141516$ python3 registration.pyrunning register(&lt;function f1 at 0x100631bf8&gt;)running register(&lt;function f2 at 0x100631c80&gt;)running main()registry -&gt; [&lt;function f1 at 0x100631bf8&gt;, &lt;function f2 at 0x100631c80&gt;]running f1()running f2()running f3()&gt;&gt;&gt; import registrationrunning register(&lt;function f1 at 0x10063b1e0&gt;)running register(&lt;function f2 at 0x10063b268&gt;)#此时查看 registry 的值，得到的输出如下：&gt;&gt;&gt; registration.registry[&lt;function f1 at 0x10063b1e0&gt;, &lt;function f2 at 0x10063b268&gt;] 上例子主要说明了装饰器的一个关键特性是，它们在被装饰的函数定义之后立即运行这通常是在导入时（即 Python 加载模块时）函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。这突出了 Python 程序员所说的导入时和运行时之间的区别。 装饰器通常在一个模块中定义，然后应用到其他模块中的函数上。 大多数装饰器会在内部定义一个函数，然后将其返回。 下面给出三种修饰器的输出，以便思考 12345678910111213&gt;&gt;&gt; def deco(func):... def inner():... print(&#x27;running inner()&#x27;)... return func...&gt;&gt;&gt; @deco... def target():... print(&#x27;running target()&#x27;)...&gt;&gt;&gt; target()running target()&lt;&lt;&lt;running target() 1234567891011&gt;&gt;&gt; def deco(func):... def inner():... print(&#x27;running inner()&#x27;)... return inner...&gt;&gt;&gt; @deco... def target():... print(&#x27;running target()&#x27;)...&gt;&gt;&gt; target()running inner() 12345678910111213&gt;&gt;&gt; def deco(func):... func()... def inner():... print(&#x27;running inner()&#x27;)... return inner...&gt;&gt;&gt; @deco... def target():... print(&#x27;running target()&#x27;)...running target()&gt;&gt;&gt; target()running inner() 变量作用域规则给出三个例子对比 1. 12345678910&gt;&gt;&gt; def f1(a):... print(a)... print(b)...&gt;&gt;&gt; f1(3)3Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 3, in f1NameError: global name &#x27;b&#x27; is not defined 2. 12345678&gt;&gt;&gt; b = 6&gt;&gt;&gt; def f1(a):... print(a)... print(b)...&gt;&gt;&gt; f1(3)36 3. 123456789101112&gt;&gt;&gt; b = 6&gt;&gt;&gt; def f2(a):... print(a)... print(b)... b = 9...&gt;&gt;&gt; f2(3)3Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 3, in f2UnboundLocalError: local variable &#x27;b&#x27; referenced before assignment 在第三个例子中Python 编译函数的定义体时，它判断 b 是局部变量，因为在函数中给它赋值了。生成的字节码证实了这种判断，Python 会尝试从本地环境获取 b。后面调用 f2(3)时， f2 的定义体会获取并打印局部变量 a 的值，但是尝试获取局部变量 b 的值时，发现b 没有绑定值。 这不是缺陷，而是设计选择：Python 不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。这比 JavaScript 的行为好多了，JavaScript 也不要求声明变量，但是如果忘记把变量声明为局部变量（使用 var），可能会在不知情的情况下获取全局变量。 如果在函数中赋值时想让解释器把 b 当成全局变量，要使用 global 声明： 123456789101112131415161718&gt;&gt;&gt; b = 6&gt;&gt;&gt; def f3(a):... global b... print(a)... print(b)... b = 9...&gt;&gt;&gt; f3(3)36&gt;&gt;&gt; b9&gt;&gt;&gt; f3(3)39&gt;&gt;&gt; b = 30&gt;&gt;&gt; b30 闭包只有涉及嵌套函数时才有闭包问题。闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。函数是不是匿名的没有关系，关键是它能访问定义体之外定义的非全局变量。 示例 123456789101112131415def make_averager(): series = [] def averager(new_value): series.append(new_value) total = sum(series) return total/len(series) return averager&gt;&gt;&gt; avg = make_averager()&gt;&gt;&gt; avg(10)10.0&gt;&gt;&gt; avg(11)10.5&gt;&gt;&gt; avg(12)11.0 series 是 make_averager 函数的局部变量，因为那个函数的定义体中初始化了series：series = []。在 averager 函数中，series 是自由变量（free variable）。这是一个技术术语，指未在本地作用域中绑定的变量 审查 make_averager（见下例）创建的函数 1234&gt;&gt;&gt; avg.__code__.co_varnames(&#x27;new_value&#x27;, &#x27;total&#x27;)&gt;&gt;&gt; avg.__code__.co_freevars(&#x27;series&#x27;,) series 的绑定在返回的 avg 函数的 closure 属性中。avg.closure 中的各个元素对应于 avg.code.co_freevars 中的一个名称。这些元素是 cell 对象，有个cell_contents 属性，保存着真正的值。这些属性的值如下例 所示。示例 接续上例 123456&gt;&gt;&gt; avg.__code__.co_freevars(&#x27;series&#x27;,)&gt;&gt;&gt; avg.__closure__(&lt;cell at 0x107a44f78: list object at 0x107a91a48&gt;,)&gt;&gt;&gt; avg.__closure__[0].cell_contents[10, 11, 12] 综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。 只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。 nonlocal声明错误示例 1234567891011121314def make_averager(): count = 0 total = 0 def averager(new_value): count += 1 total += new_value return total / count return averager&gt;&gt;&gt; avg = make_averager()&gt;&gt;&gt; avg(10)Traceback (most recent call last): ...UnboundLocalError: local variable &#x27;count&#x27; referenced before assignment 对数字、字符串、元组等不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如 count = count + 1，其实会隐式创建局部变量 count。这样，count 就不是自由变量了，因此不会保存在闭包中。而之前的列表series，我们没有给 series 赋值，我们只是调用series.append，并把它传给 sum 和 len。也就是说，我们利用了列表是可变的对象这一事实。 为了解决这个问题，Python 3 引入了 nonlocal 声明。它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为 nonlocal 声明的变量赋予新值，闭包中保存的绑定会更新。最新版 make_averager 的正确实现如示例 7-14 所示。 正确示例 123456789def make_averager(): count = 0 total = 0 def averager(new_value): nonlocal count, total count += 1 total += new_value return total / count return averager 对于python2中没有nonlocal声明的替代方法把内部函数需要修改的变量（如 count 和 total）存储为可变对象（如字典或简单的实例）的元素或属性，并且把那个对象绑定给一个自由变量。也就是利用可变对象的可变。 修饰器原理1234567891011121314151617181920212223import timedef clock(func): def clocked(*args): # 定义内部函数 clocked，它接受任意个定位参数。 t0 = time.perf_counter() result = func(*args) # 这行代码可用，是因为 clocked 的闭包中包含自由变量 func。 elapsed = time.perf_counter() - t0 name = func.__name__ arg_str = &#x27;, &#x27;.join(repr(arg) for arg in args) print(&#x27;[%0.8fs] %s(%s) -&gt; %r&#x27; % (elapsed, name, arg_str, result)) return result return clocked # 返回内部函数，取代被装饰的函数。示例 7-16 演示了 clock 装饰器的用法。@clockdef snooze(seconds): time.sleep(seconds)@clockdef factorial(n): return 1 if n &lt; 2 else n*factorial(n-1)if __name__==&#x27;__main__&#x27;: print(&#x27;*&#x27; * 40, &#x27;Calling snooze(.123)&#x27;) snooze(.123) print(&#x27;*&#x27; * 40, &#x27;Calling factorial(6)&#x27;) print(&#x27;6! =&#x27;, factorial(6)) 123@clockdef factorial(n): return 1 if n &lt; 2 else n*factorial(n-1) 等价于 123def factorial(n): return 1 if n &lt; 2 else n*factorial(n-1)factorial = clock(factorial) 在修饰器里factorial 会作为 func 参数传给 clock。然后，factorial其实已经成为了clocked的自由变量了，然后 clock 函数会返回 clocked 函数，Python 解释器在背后会把 clocked 赋值给factorial。此时的factorial已经是clocked函数的引用了。而真正的一开始的factorial函数已经是clocked函数的自由变量。从而形成嵌套函数我们可以查看 factorial 的 name 属性，会得到如下结果： 123&gt;&gt;&gt; import clockdeco_demo&gt;&gt;&gt; clockdeco_demo.factorial.__name__&#x27;clocked&#x27; 所以，现在 factorial 保存的是 clocked 函数的引用。自此之后，每次调用factorial(n)，执行的都是 clocked(n)。clocked 大致做了下面几件事。 (1) 记录初始时间 t0。(2) 调用原来的 factorial 函数，保存结果。(3) 计算经过的时间。(4) 格式化收集的数据，然后打印出来。(5) 返回第 2 步保存的结果。这是装饰器的典型行为：把被装饰的函数替换成新函数，二者接受相同的参数，而且（通常）返回被装饰的函数本该返回的值，同时还会做些额外操作。 使用functools.lru_cache做备忘functools.lru_cache 是非常实用的装饰器，它实现了备忘（memoization）功能。这是一项优化技术，它把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。LRU三个字母是“Least Recently Used”的缩写，表明缓存不会无限制增长，一段时间不用的缓存条目会被扔掉。 示例 1234567891011121314151617181920import functoolsfrom clockdeco import clock@functools.lru_cache() # 注意，必须像常规函数那样调用 lru_cache。这一行中有一对括号：@functools.lru_cache()。这么做的原因是，lru_cache 可以接受配置参数，稍后说明。@clock # 这里叠放了装饰器：@lru_cache() 应用到 @clock 返回的函数上。def fibonacci(n): if n &lt; 2: return n return fibonacci(n-2) + fibonacci(n-1)if __name__==&#x27;__main__&#x27;: print(fibonacci(6))#这样一来，执行时间减半了，而且 n 的每个值只调用一次函数：$ python3 fibo_demo_lru.py[0.00000119s] fibonacci(0) -&gt; 0[0.00000119s] fibonacci(1) -&gt; 1[0.00010800s] fibonacci(2) -&gt; 1[0.00000787s] fibonacci(3) -&gt; 2[0.00016093s] fibonacci(4) -&gt; 3[0.00001216s] fibonacci(5) -&gt; 5[0.00025296s] fibonacci(6) -&gt; 8 特别要注意，lru_cache 可以使用两个可选的参数来配置。它的签名是： 1functools.lru_cache(maxsize=128, typed=False) maxsize 参数指定存储多少个调用的结果。缓存满了之后，旧的结果会被扔掉，腾出空间。为了得到最佳性能，maxsize 应该设为 2 的幂。 typed 参数如果设为 True，把不同参数类型得到的结果分开保存，即把通常认为相等的浮点数和整数参数（如 1 和 1.0）区分开。 顺便说一下，因为 lru_cache 使用字典存储结果，而且键根据调用时传入的定位参数和关键字参数创建，所以被 lru_cache 装饰的函数，它的所有参数都必须是可散列的。 functools.singledispatch 装饰器单分派泛函数 Python 3.4 新增的 functools.singledispatch 装饰器可以把整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。使用 @singledispatch 装饰的普通函数会变成泛函数（generic function）：根据第一个参数的类型，以不同方式执行相同操作的一组函数。 这就是单分派。如果根据多个参数选择专门的函数，那就是多分派了。","categories":[{"name":"Python","slug":"Python","permalink":"http://diudiu6.com/categories/Python/"},{"name":"流畅的python","slug":"Python/流畅的python","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"第七章","slug":"Python/流畅的python/第七章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E4%B8%83%E7%AB%A0/"}],"tags":[{"name":"流畅的python","slug":"流畅的python","permalink":"http://diudiu6.com/tags/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"learning","slug":"learning","permalink":"http://diudiu6.com/tags/learning/"}]},{"title":"一等函数","slug":"一等函数","date":"2019-02-01T14:03:30.000Z","updated":"2019-03-13T11:02:23.000Z","comments":true,"path":"2019/02/01/一等函数/","link":"","permalink":"http://diudiu6.com/2019/02/01/%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0/","excerpt":"“一等对象”定义为满足下述条件的程序实体：在运行时创建能赋值给变量或数据结构中的元素能作为参数传给函数能作为函数的返回结果","text":"“一等对象”定义为满足下述条件的程序实体：在运行时创建能赋值给变量或数据结构中的元素能作为参数传给函数能作为函数的返回结果 sum 和 reduce 的通用思想是把某个操作连续应用到序列的元素上，累计之前的结果，把一系列值归约成一个值。all 和 any 也是内置的归约函数。all(iterable)如果 iterable 的每个元素都是真值，返回 True；all([]) 返回 True。any(iterable) 只要 iterable 中有元素是真值，就返回 True；any([]) 返回 False。 匿名函数lambda 关键字在 Python 表达式内创建匿名函数 与 def 语句一样，lambda 表达式会创建函数对象。这是Python 中几种可调用对象的一种。 调用运算符（即 ()）可调用对象： ·用户定义的函数·内置函数 使用 C 语言（CPython）实现的函数，如 len 或 time.strftime。·内置方法 使用 C 语言实现的方法，如 dict.get。·类 调用类时会运行类的 new 方法创建一个实例，然后运行 init 方法，初始 化实例，最后把实例返回给调用方。调用类相当于调用函数。·类的实例 如果类定义了 call 方法，那么它的实例可以作为函数调用。·生成器函数(比较特殊，详见 14 章。生成器函数还可以作为协程，参见第 16 章。) 使用 yield 关键字的函数或方法。调用生成器函数返回的是生成器对象。 callable() 函数 判断对象能否调用 不仅 Python 函数是真正的对象，任何 Python 对象都可以表现得像函数。为此，只需实现实例方法 __call__。 实现 call 方法的类是创建函数类对象的简便方式 除了 __doc__，函数对象还有很多属性。使用 dir 函数可以探知 一个对象具有的属性例如 12&gt;&gt;&gt; dir(int)&gt;&gt;&gt; [&#x27;__abs__&#x27;, &#x27;__add__&#x27;, &#x27;__and__&#x27;, &#x27;__bool__&#x27;, &#x27;__ceil__&#x27;, &#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dir__&#x27;, &#x27;__divmod__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__float__&#x27;, &#x27;__floor__&#x27;, &#x27;__floordiv__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__getnewargs__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__index__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__int__&#x27;, &#x27;__invert__&#x27;, &#x27;__le__&#x27;, &#x27;__lshift__&#x27;, &#x27;__lt__&#x27;, &#x27;__mod__&#x27;, &#x27;__mul__&#x27;, &#x27;__ne__&#x27;, &#x27;__neg__&#x27;, &#x27;__new__&#x27;, &#x27;__or__&#x27;, &#x27;__pos__&#x27;, &#x27;__pow__&#x27;, &#x27;__radd__&#x27;, &#x27;__rand__&#x27;, &#x27;__rdivmod__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__rfloordiv__&#x27;, &#x27;__rlshift__&#x27;, &#x27;__rmod__&#x27;, &#x27;__rmul__&#x27;, &#x27;__ror__&#x27;, &#x27;__round__&#x27;, &#x27;__rpow__&#x27;, &#x27;__rrshift__&#x27;, &#x27;__rshift__&#x27;, &#x27;__rsub__&#x27;, &#x27;__rtruediv__&#x27;, &#x27;__rxor__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__sub__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__truediv__&#x27;, &#x27;__trunc__&#x27;, &#x27;__xor__&#x27;, &#x27;bit_length&#x27;, &#x27;conjugate&#x27;, &#x27;denominator&#x27;, &#x27;from_bytes&#x27;, &#x27;imag&#x27;, &#x27;numerator&#x27;, &#x27;real&#x27;, &#x27;to_bytes&#x27;] Python 3 提供了仅限关键字参数（keyword-only argument）调用函数时使用 * 和** “展开” 可迭代对象，映射到单个参数。 *args可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。 用法: 123456789101112131415def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum#笨方法&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])&gt;&gt;&gt; 14#聪明方法,可以在list或tuple前面加一个*号，把list或tuple的元素变成#可变参数传进去&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)&gt;&gt;&gt; 14 **kwargs关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict 用法: 123456789101112131415def person(name, age, **kw): print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw)#笨方法&gt;&gt;&gt; extra = &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, city=extra[&#x27;city&#x27;], job=extra[&#x27;job&#x27;])&gt;&gt;&gt; name: Jack age: 24 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;#聪明方法 #用**extra表示把extra这个dict的所有key-value用关键字参数#传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的#一份拷贝，对kw的改动不会影响到函数外的extra&gt;&gt;&gt; extra = &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, **extra)&gt;&gt;&gt; name: Jack age: 24 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125; 仅限关键词参数 KEYWORD_ONLY 和关键字参数*kw不同，仅限关键词参数需要一个特殊分隔符，*后面的参数被视为仅限关键词参数。 用法: 12345def person(name, age, *, city, job): print(name, age, city, job)&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, city=&#x27;Beijing&#x27;, job=&#x27;Engineer&#x27;)&gt;&gt;&gt; Jack 24 Beijing Engineer 如果函数定义中已经有了一个可变参数，后面跟着的仅限关键词参数就不再需要一个特殊分隔符*了： 12def person(name, age, *args, city, job): print(name, age, args, city, job) 仅限关键词参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错： 123456&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, &#x27;Beijing&#x27;, &#x27;Engineer&#x27;)&gt;&gt;&gt; Traceback (most recent call last):&gt;&gt;&gt; File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;&gt;&gt;&gt; TypeError: person() takes 2 positional arguments but 4 were given&gt;&gt;&gt; 由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，&gt;&gt;&gt; 但person()函数仅接受2个位置参数。 使用仅限关键词参数时，要特别注意，如果没有可变参数，就必须加一个作为特殊分隔符。如果缺少，Python解释器将无法识别位置参数和仅限关键词参数： 仅限关键词参数不一定要有默认值，但此时强制必须传入实参。 Python 中函数的参数可以分为两大类： 定位参数（Positional）：表示参数的位置是固定的。比如对于函数 foo(a, b) 来说，foo(1, 2) 和 foo(2, 1) 就是截然不同的，a 和 b 的位置是固定的，不可随意调换。关键词参数（Keyword）：表示参数的位置不重要，但是参数名称很重要。比如 foo(a = 1, b = 2) 和 foo(b = 2, a = 1) 的含义相同。 def foo(args, n=1, **kwargs): print(n)这个函数在调用时，如果参数 n 不指定名字，就会被前面的 *args 处理掉，如果指定的名字不是 n，又会被后面的 *kwargs 处理掉，所以参数 n 必须精确的以 (n = xxx) 的形式出现，也就是 KEYWORD_ONLY。 函数对象有个 defaults 属性，它的值是一个元组，里面保存着定位参数和关键字参数的默认值。仅限关键字参数的默认值在 kwdefaults 属性中。然而，参数的名称在 code 属性中，它的值是一个 code 对象引用，自身也有很多属性。 #text 定位参数 max_len 关键词参数 a 仅限关键词参数 如果a没有默认值，clip初始化时需要传入a 123456789101112131415161718192021222324def clip(text, max_len=80,*,a): &quot;&quot;&quot;在max_len前面或后面的第一个空格处截断文本 &quot;&quot;&quot; end = None if len(text) &gt; max_len: space_before = text.rfind(&#x27; &#x27;, 0, max_len) if space_before &gt;= 0: end = space_before else: space_after = text.rfind(&#x27; &#x27;, max_len) if space_after &gt;= 0: end = space_after if end is None: # 没找到空格 end = len(text) return text[:end].rstrip()&gt;&gt;&gt; clip.__defaults__&gt;&gt;&gt; (80,)&gt;&gt;&gt; clip.__code__ # doctest: +ELLIPSIS&gt;&gt;&gt; &lt;code object clip at 0x...&gt;&gt;&gt;&gt; clip.__code__.co_varnames&gt;&gt;&gt; (&#x27;text&#x27;, &#x27;max_len&#x27;, &#x27;end&#x27;, &#x27;space_before&#x27;, &#x27;space_after&#x27;)&gt;&gt;&gt; clip.__code__.co_argcount&gt;&gt;&gt; 2 提取函数的签名inspect.signature 函数返回一个 inspect.Signature 对象，它有一个 parameters 属性，这是一个有序映射，把参数名和 inspect.Parameter 对象对应起来。各个 Parameter 属性也有自己的属性，例如 name、default 和 kind。特殊的inspect._empty 值表示没有默认值，注意 None 是有效的默认值不会显示inspect._empty（也经常这么做），而且这么做是合理的。 1234567891011&gt;&gt;&gt; from inspect import signature&gt;&gt;&gt; sig = signature(clip)&gt;&gt;&gt; sig # doctest: +ELLIPSIS&gt;&gt;&gt; &lt;inspect.Signature object at 0x...&gt;&gt;&gt;&gt; str(sig)&gt;&gt;&gt; &#x27;(text, max_len=80)&#x27;&gt;&gt;&gt; for name, param in sig.parameters.items():&gt;&gt;&gt; print(param.kind, &#x27;:&#x27;, param.name, &#x27;=&#x27;, param.default)POSITIONAL_OR_KEYWORD : text = &lt;class &#x27;inspect._empty&#x27;&gt;POSITIONAL_OR_KEYWORD : max_len = 80 注解inspect.Parameter 对象还有一个 annotation（注解）属性 函数声明中的各个参数可以在 : 之后增加注解表达式。如果参数有默认值，注解放在参数名和 = 号之间。如果想注解返回值，在 ) 和函数声明末尾的 : 之间添加 -&gt; 和一个表达式。那个表达式可以是任何类型。注解中最常用的类型是类（如 str 或 int）和字符串（如 ‘int &gt; 0’）。在示例 5-19 中，max_len 参数的注解用的是字符串。 12345def clip(text:str, max_len:&#x27;int &gt; 0&#x27;=80) -&gt; str: return text clip.__annotations__&#123;&#x27;text&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;max_len&#x27;: &#x27;int &gt; 0&#x27;, &#x27;return&#x27;: &lt;class &#x27;str&#x27;&gt;&#125; Python 对注解所做的唯一的事情是，把它们存储在函数的 annotations 属性里。仅此而已，Python 不做检查、不做强制、不做验证，什么操作都不做。 123456789&gt;&gt;&gt; from inspect import signature&gt;&gt;&gt; sig = signature(clip)&gt;&gt;&gt; sig.return_annotation&gt;&gt;&gt; &lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; for param in sig.parameters.values():&gt;&gt;&gt; ... note = repr(param.annotation).ljust(13)&gt;&gt;&gt; ... print(note, &#x27;:&#x27;, param.name, &#x27;=&#x27;, param.default)&gt;&gt;&gt; &lt;class &#x27;str&#x27;&gt; : text = &lt;class &#x27;inspect._empty&#x27;&gt;&gt;&gt;&gt; &#x27;int &gt; 0&#x27; : max_len = 80 operator 模块 使用 reduce 函数和一个匿名函数计算阶乘 123456789101112131415161718from functools import reducedef fact(n): return reduce(lambda a, b: a*b, range(1, n+1))使用 reduce 和 operator.mul 函数计算阶乘from functools import reducefrom operator import muldef fact(n): return reduce(mul, range(1, n+1)) metro_data = [... (&#x27;Tokyo&#x27;, &#x27;JP&#x27;, 36.933, (35.689722, 139.691667)),... (&#x27;Delhi NCR&#x27;, &#x27;IN&#x27;, 21.935, (28.613889, 77.208889)),... (&#x27;Mexico City&#x27;, &#x27;MX&#x27;, 20.142, (19.433333, -99.133333)),... (&#x27;New York-Newark&#x27;, &#x27;US&#x27;, 20.104, (40.808611, -74.020386)),... (&#x27;Sao Paulo&#x27;, &#x27;BR&#x27;, 19.649, (-23.547778, -46.635833)),... ] itemgetter(1) 的作用与 lambda fields: fields[1] 一样：创建一个接受集合的函数，返回索引位 1 上的元素。 123456789from operator import itemgetterfor city in sorted(metro_data, key=itemgetter(1)):... print(city)...(&#x27;Sao Paulo&#x27;, &#x27;BR&#x27;, 19.649, (-23.547778, -46.635833))(&#x27;Delhi NCR&#x27;, &#x27;IN&#x27;, 21.935, (28.613889, 77.208889))(&#x27;Tokyo&#x27;, &#x27;JP&#x27;, 36.933, (35.689722, 139.691667))(&#x27;Mexico City&#x27;, &#x27;MX&#x27;, 20.142, (19.433333, -99.133333))(&#x27;New York-Newark&#x27;, &#x27;US&#x27;, 20.104, (40.808611, -74.020386)) 如果把多个参数传给 itemgetter，它构建的函数会返回提取的值构成的元组 123456789&gt;&gt;&gt; cc_name = itemgetter(1, 0)&gt;&gt;&gt; for city in metro_data:&gt;&gt;&gt; ... print(cc_name(city))&gt;&gt;&gt; ...&gt;&gt;&gt; (&#x27;JP&#x27;, &#x27;Tokyo&#x27;)&gt;&gt;&gt; (&#x27;IN&#x27;, &#x27;Delhi NCR&#x27;)&gt;&gt;&gt; (&#x27;MX&#x27;, &#x27;Mexico City&#x27;)&gt;&gt;&gt; (&#x27;US&#x27;, &#x27;New York-Newark&#x27;)&gt;&gt;&gt; (&#x27;BR&#x27;, &#x27;Sao Paulo&#x27;)","categories":[{"name":"Python","slug":"Python","permalink":"http://diudiu6.com/categories/Python/"},{"name":"流畅的python","slug":"Python/流畅的python","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"第五章","slug":"Python/流畅的python/第五章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E4%BA%94%E7%AB%A0/"}],"tags":[{"name":"流畅的python","slug":"流畅的python","permalink":"http://diudiu6.com/tags/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"learning","slug":"learning","permalink":"http://diudiu6.com/tags/learning/"}]},{"title":"使用一等函数设计模式","slug":"使用一等函数设计模式","date":"2019-02-01T11:12:52.000Z","updated":"2020-08-26T05:45:36.000Z","comments":true,"path":"2019/02/01/使用一等函数设计模式/","link":"","permalink":"http://diudiu6.com/2019/02/01/%E4%BD%BF%E7%94%A8%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"《设计模式：可复用面向对象软件的基础》一书的作者指出：“策略对象通常是很好的享元（flyweight）。” “享元”定义：“享元是可共享的对象，可以同时在多个上下文中使用。” 共享是推荐的做法，这样不必在每个新的上下文中使用相同的策略时不断新建具体策略对象，从而减少消耗。因此，为了避免“策略”模式的一个缺点（运行时消耗） 具体策略一般没有内部状态，只是处理上下文中的数据。此时，一定要使用普通的函数，别去编写只有一个方法的类，再去实现另一个类声明的单函数接口。函数比用户定义的类的实例轻量，而且无需使用“享元”模式，因为各个策略函数在 Python 编译模块时只会创建一次。普通的函数也是“可共享的对象，可以同时在多个上下文中使用”。 globals()返回一个字典，表示当前的全局符号表。这个符号表始终针对当前模块（对函数或方法来说，是指定义它们的模块，而不是调用它们的模块）。 “命令”模式的目的是解耦调用操作的对象（调用者）和提供实现的对象（接收者）。调用者是图形应用程序中的菜单项，而接收者是被编辑的文档或应用程序自身。 inspect.getmembers 函数用于获取对象（这里是 promotions模块）的属性，第二个参数是可选的判断条件（一个布尔值函数）。我们使用的是 inspect.isfunction，只获取模块中的函数。 把实现单方法接口的类的实例替换成可调用对象。毕竟，每个Python 可调用对象都实现了单方法接口，这个方法就是 __call__。","categories":[{"name":"Python","slug":"Python","permalink":"http://diudiu6.com/categories/Python/"},{"name":"流畅的python","slug":"Python/流畅的python","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"第六章","slug":"Python/流畅的python/第六章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E5%85%AD%E7%AB%A0/"}],"tags":[{"name":"流畅的python","slug":"流畅的python","permalink":"http://diudiu6.com/tags/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"learning","slug":"learning","permalink":"http://diudiu6.com/tags/learning/"}]},{"title":"文本和字节序列","slug":"文本和字节序列","date":"2019-01-31T13:59:31.000Z","updated":"2019-03-13T11:01:51.000Z","comments":true,"path":"2019/01/31/文本和字节序列/","link":"","permalink":"http://diudiu6.com/2019/01/31/%E6%96%87%E6%9C%AC%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97/","excerpt":"一个字符串是一个字符序列。字符是Unicode字符字符的标识是码位。字符的具体表述取决于所用的编码。","text":"一个字符串是一个字符序列。字符是Unicode字符字符的标识是码位。字符的具体表述取决于所用的编码。 123456789&gt;&gt;&gt; s = &#x27;cafe&#x27;&gt;&gt;&gt; b = s.encode(&#x27;utf8&#x27;) #使用UTF-8把str对象编码成bytes对象 把码位转换成字节序列&gt;&gt;&gt; a = b.decode(&#x27;utf8&#x27;) #使用UTF-8把bytes对象解码成str对象 把字节序列转换成码位&gt;&gt;&gt; b&gt;&gt;&gt; b&#x27;cafe&#x27;&gt;&gt;&gt; a&gt;&gt;&gt; &#x27;cafe&#x27;&gt;&gt;&gt; s&gt;&gt;&gt; &#x27;cafe&#x27; bytes 字面量以b开头python3里的 str 类型相当于python2 里的 Unicode类型 bytes 或 bytearry 对象的各个元素是介于0-255（含）之间的整数bytes 的切片仍然是 bytes 对象my_bytes[0] == my_bytes[:1]书本P85 re模块中的正则表达式也能处理二进制序列 123456&gt;&gt;&gt; a =5&gt;&gt;&gt; del a&gt;&gt;&gt; a&gt;&gt;&gt; Traceback (most recent call last):&gt;&gt;&gt; File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;&gt;&gt;&gt; NameError: name &#x27;a&#x27; is not defined del 释放内存 memory viewsdocs.python.org/3/library/stdtypes.html#memory-viewsstructdocs.python.org/3/library/struct.html UnicodeEncodeError 把字符串转换成二进制序列时的问题UnicodeDecodeError 把二进制序列转换成字符串时的问题SyntaxError 如果源码的编码与预期不符，加载python模块时的问题 s.encode(‘utf8’,errors = ‘ignore’) 把无法编码的字符跳过s.encode(‘utf8’,errors = ‘replace’) 把无法编码的字符代替为 ‘?’s.encode(‘utf8’,errors = ‘xmlcharrefreplace’) 把无法编码的字符替换成XML实体 处理文本的最佳实践是“Unicode 三明治”。要尽早把输入（例如读取文件时）的字节序列解码成字符串。这种三明治中的“肉片”是程序的业务逻辑，在这里只能处理字符串对象。在其他处理过程中，一定不能编码或解码。对输出来说，则要尽量晚地把字符串编码成字节序列。 python3内置的 open 函数会在读取文件时做必要的解码，以文本模式写入文件时还会做必要的编码，所以调用 my_file.read()方法得到的以及传给 my_file.write(text)方法的都是字符串对象如果依赖默认编码，会遇到麻烦。系统默认的编码（Windows 1252） 需要在多台设备中或多种场合下运行的代码，一定不能依赖默认编码。打开文件时始终应该明确传入 encoding= 参数，因为不同的设备使用的默认编码可能不同，有时隔一天也会发生变化。 如果打开文件是为了写入，但是没有指定编码参数，会使用区域设置中的默认编码，而且使用那个编码也能正确读取文件。但是，如果脚本要生成文件，而字节的内容取决于平台或同一平台中的区域设置，那么就可能导致兼容问题。 12345678910111213141516171819202122232425262728&gt;&gt;&gt; fp = open(&#x27;cafe.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf_8&#x27;)&gt;&gt;&gt; fp # 默认情况下，open 函数采用文本模式，返回一个 TextIOWrapper 对象。&gt;&gt;&gt; &lt;_io.TextIOWrapper name=&#x27;cafe.txt&#x27; mode=&#x27;w&#x27; encoding=&#x27;utf_8&#x27;&gt;&gt;&gt;&gt; fp.write(&#x27;café&#x27;)&gt;&gt;&gt; 4 # 在 TextIOWrapper 对象上调用 write 方法返回写入的 Unicode 字符数。&gt;&gt;&gt; fp.close()&gt;&gt;&gt; import os&gt;&gt;&gt; os.stat(&#x27;cafe.txt&#x27;).st_size&gt;&gt;&gt; 5 # os.stat 报告文件中有 5 个字节；UTF-8 编码的 &#x27;é&#x27; 占两个字节，0xc3 和 0xa9。&gt;&gt;&gt; fp2 = open(&#x27;cafe.txt&#x27;)&gt;&gt;&gt; fp2 # 打开文本文件时没有显式指定编码，返回一个 TextIOWrapper 对象，编码是区域设置&gt;&gt;&gt; #中的默认值&gt;&gt;&gt; &lt;_io.TextIOWrapper name=&#x27;cafe.txt&#x27; mode=&#x27;r&#x27; encoding=&#x27;cp1252&#x27;&gt;&gt;&gt;&gt; fp2.encoding #TextIOWrapper 对象有个 encoding 属性；查看它，发现这里的编码是 cp1252。&gt;&gt;&gt; &#x27;cp1252&#x27;&gt;&gt;&gt; fp2.read()&gt;&gt;&gt; &#x27;cafÃ©&#x27; # 在 Windows cp1252 编码中，0xc3 字节是“Ã”（带波形符的 A），0xa9 字节是版权符&gt;&gt;&gt; 号。&gt;&gt;&gt; fp3 = open(&#x27;cafe.txt&#x27;, encoding=&#x27;utf_8&#x27;) # 使用正确的编码打开那个文件。&gt;&gt;&gt; fp3&gt;&gt;&gt; &lt;_io.TextIOWrapper name=&#x27;cafe.txt&#x27; mode=&#x27;r&#x27; encoding=&#x27;utf_8&#x27;&gt;&gt;&gt;&gt; fp3.read()&gt;&gt;&gt; &#x27;café&#x27; #结果符合预期：得到的是四个 Unicode 字符 &#x27;café&#x27;。&gt;&gt;&gt; fp4 = open(&#x27;cafe.txt&#x27;, &#x27;rb&#x27;) # &#x27;rb&#x27; 标志指明在二进制模式中读取文件。&gt;&gt;&gt; fp4&gt;&gt;&gt; &lt;_io.BufferedReader name=&#x27;cafe.txt&#x27;&gt; # 返回的是 BufferedReader 对象，而不是 TextIOWrapper 对象。&gt;&gt;&gt; fp4.read() #读取返回的字节序列，结果与预期相符。&gt;&gt;&gt; b&#x27;caf\\xc3\\xa9&#x27; 1234567891011locale.getpreferredencoding() -&gt; &#x27;cp936&#x27;# locale.getpreferredencoding() 是最重要的设置。 type(my_file) -&gt; &lt;class &#x27;_io.TextIOWrapper&#x27;&gt; my_file.encoding -&gt; &#x27;cp936&#x27;# 文本文件默认使用 locale.getpreferredencoding()。 sys.stdout.isatty() -&gt; True# 输出到控制台中，因此 sys.stdout.isatty() 返回 True。 sys.stdout.encoding -&gt; &#x27;utf-8&#x27;# 因此，sys.stdout.encoding 与控制台的编码相同。 sys.stdin.isatty() -&gt; True sys.stdin.encoding -&gt; &#x27;utf-8&#x27; sys.stderr.isatty() -&gt; True sys.stderr.encoding -&gt; &#x27;utf-8&#x27; sys.getdefaultencoding() -&gt; &#x27;utf-8&#x27; sys.getfilesystemencoding() -&gt; &#x27;utf-8&#x27; 关于编码默认值的最佳建议是：别依赖默认值。 使用 unicodedata.normalize 函数提供的 Unicode 规范化。这个函数的第一个参数是这 4 个字符串中的一个：’NFC’、’NFD’、’NFKC’ 和 ‘NFKD’。NFC（Normalization Form C）使用最少的码位构成等价的字符串NFD 把组合字符分解成基字符和单独的组合字符。 西方键盘通常能输出组合字符，因此用户输入的文本默认是 NFC 形式。不过，安全起见，保存文本之前，最好使用 normalize(‘NFC’, user_text) 清洗字符串。 使用 NFC 时，有些单字符会被规范成另一个单字符。这两个字符在视觉上是一样的，但是比较时并不相等，因整理此要规范化，防止出现意外 另外两个规范化形式（NFKC 和 NFKD）的首字母缩略词中，字母 K 表示“compatibility”（兼容性）。这两种是较严格的规范化形式，对“兼容字符”有影响。在 NFKC 和 NFKD 形式中，各个兼容字符会被替换成一个或多个“兼容分解”字符，即便这样有些格式损失，但仍是“首选”表述——理想情况下，格式化是外部标记的职责，不应该由 Unicode 处理。下面举个例子。二分之一 ‘½’（U+00BD）经过兼容分解后得到的是三个字符序列 ‘1/2’；微符号 ‘µ’（U+00B5）经过兼容分解后得到的是小写字母‘μ’（U+03BC）。 str.casefold() 大小写折叠——把所有文本变成小写str.casefold() 和 str.lower() 得到不同结果的有 116 个码位。 对于只包含 latin1 字符的字符串 s，s.casefold() 得到的结果与 s.lower() 一样，唯有两个例外：微符号 ‘µ’ 会变成小写的希腊字母“μ”（在多数字体中二者看起来一样）；德语 Eszett（“sharp s”，ß）会变成“ss”。 re.compile(r’\\d+’) 字符串类型re.compile(rb’\\d+’) 字节类型字符串正则表达式有个 re.ASCII 标志，它让 \\w、\\W、\\b、\\B、\\d、\\D、\\s 和 \\S 只匹配 ASCII 字符。re模块 https://docs.python.org/3/library/re.html 123456789101112131415import rere_numbers_str = re.compile(r&#x27;\\d+&#x27;) ➊re_words_str = re.compile(r&#x27;\\w+&#x27;)re_numbers_bytes = re.compile(rb&#x27;\\d+&#x27;) ➋re_words_bytes = re.compile(rb&#x27;\\w+&#x27;)text_str = (&quot;Ramanujan saw \\u0be7\\u0bed\\u0be8\\u0bef&quot; ➌ &quot; as 1729 = 1³ + 12³ = 9³ + 10³.&quot;) ➍text_bytes = text_str.encode(&#x27;utf_8&#x27;) ➎print(&#x27;Text&#x27;, repr(text_str), sep=&#x27;\\n &#x27;)print(&#x27;Numbers&#x27;)print(&#x27; str :&#x27;, re_numbers_str.findall(text_str)) ➏print(&#x27; bytes:&#x27;, re_numbers_bytes.findall(text_bytes)) ➐print(&#x27;Words&#x27;)print(&#x27; str :&#x27;, re_words_str.findall(text_str)) ➑print(&#x27; bytes:&#x27;, re_words_bytes.findall(text_bytes)) ➒ 前两个正则表达式是字符串类型。 后两个正则表达式是字节序列类型。 要搜索的 Unicode 文本，包括 1729 的泰米尔数字（逻辑行直到右括号才结束）。 这个字符串在编译时与前一个拼接起来（参见 Python 语言参考手册中的“2.4.2. String literal concatenation”，https://docs.python.org/3/reference/lexical_analysis.html#string-literal- concatenation）。 字节序列只能用字节序列正则表达式搜索。 字符串模式 r’\\d+’ 能匹配泰米尔数字和 ASCII 数字。 字节序列模式 rb’\\d+’ 只能匹配 ASCII 字节中的数字。 字符串模式 r’\\w+’ 能匹配字母、上标、泰米尔数字和 ASCII 数字。 字节序列模式 rb’\\w+’ 只能匹配 ASCII 字节中的字母和数字。","categories":[{"name":"Python","slug":"Python","permalink":"http://diudiu6.com/categories/Python/"},{"name":"流畅的python","slug":"Python/流畅的python","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"第四章","slug":"Python/流畅的python/第四章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E5%9B%9B%E7%AB%A0/"}],"tags":[{"name":"流畅的python","slug":"流畅的python","permalink":"http://diudiu6.com/tags/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"learning","slug":"learning","permalink":"http://diudiu6.com/tags/learning/"}]},{"title":"字典和集合","slug":"字典和集合","date":"2019-01-30T13:59:31.000Z","updated":"2019-03-13T11:02:08.000Z","comments":true,"path":"2019/01/30/字典和集合/","link":"","permalink":"http://diudiu6.com/2019/01/30/%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/","excerpt":"语法：isinstance（object，type）作用：来判断一个对象是否是一个已知的类型。 其第一个参数（object）为对象，第二个参数（type）为类型名(int…)或类型名的一个列表((int,list,float)是一个列表。其返回值为布尔型（True or flase）。 若对象的类型与参数二的类型相同则返回True。若参数二为一个元组，则若对象类型与元组中类型名之一相同即返回True。 散列类型的定义 https://docs.python.org/3/glossary.html#term-hashable如果一个对象是可散列（可哈希）的，那么在这个对象的生命周期里，他的散列值（哈希值）是不变的，而且这个对象需要实现 hash() 方法，另外可散列对象还要有 eq()方法，这样才能跟其他键作比较。如果两个可散列对象是相等的，那么他们的散列值一定是一样的。原子不可变数据类型（str， bytes 和数据类型）都是可散列类型，frozenset 也是。元组的话，需要一个元组内所有的元素都是可散列类型，他才是可散列类型。 散列值是它们的 id() 函数的返回值","text":"语法：isinstance（object，type）作用：来判断一个对象是否是一个已知的类型。 其第一个参数（object）为对象，第二个参数（type）为类型名(int…)或类型名的一个列表((int,list,float)是一个列表。其返回值为布尔型（True or flase）。 若对象的类型与参数二的类型相同则返回True。若参数二为一个元组，则若对象类型与元组中类型名之一相同即返回True。 散列类型的定义 https://docs.python.org/3/glossary.html#term-hashable如果一个对象是可散列（可哈希）的，那么在这个对象的生命周期里，他的散列值（哈希值）是不变的，而且这个对象需要实现 hash() 方法，另外可散列对象还要有 eq()方法，这样才能跟其他键作比较。如果两个可散列对象是相等的，那么他们的散列值一定是一样的。原子不可变数据类型（str， bytes 和数据类型）都是可散列类型，frozenset 也是。元组的话，需要一个元组内所有的元素都是可散列类型，他才是可散列类型。 散列值是它们的 id() 函数的返回值 12345&gt;&gt;&gt; a=5&gt;&gt;&gt; id(a)1863412880&gt;&gt;&gt; hash(a)5 dict 字典 https://docs.python.org/3/library/stdtypes.html#mapping-types-dict值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。 创建字典的多种方式 1234567&gt;&gt;&gt; a = dict(one=1, two=2, three=3)&gt;&gt;&gt; b = &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125; #one为键，1为值&gt;&gt;&gt; c = dict(zip([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;], [1, 2, 3]))&gt;&gt;&gt; d = dict([(&#x27;two&#x27;, 2), (&#x27;one&#x27;, 1), (&#x27;three&#x27;, 3)])&gt;&gt;&gt; e = dict(&#123;&#x27;three&#x27;: 3, &#x27;one&#x27;: 1, &#x27;two&#x27;: 2&#125;)&gt;&gt;&gt; a == b == c == d == eTrue 字典推导（dictcomp）可以从任何以键值对作为元素的可迭代对象中构建出字典 123456&gt;&gt;&gt; di =[(&#x27;dfsgs&#x27;,41),... (&#x27;wefcwe&#x27;,12)... ]&gt;&gt;&gt; cou=&#123;co:code for code, co in di&#125;&gt;&gt;&gt; cou&#123;41: &#x27;dfsgs&#x27;, 12: &#x27;wefcwe&#x27;&#125; dict.setdefault(k,[default]) 若字典里有键k，则直接返回k所对应的值；若无，则让dict[k]=default,然后返回default. 我们可以自己继承字典然后实现 missing()，这样也能使得该字典在dict[key]（即调用 getiem()时）实现该功能collection.defaultdict也有此功能(也是靠missing()实现的)index = collection.defaultdict(list)index[key] 如果key不存在index的键，则调用list()建立一个新列表，吧这个新列表作为值，key作为键放到index中，然后返回这个列表的引用书本P62 http://www.pingo.io/docs/ 123456789101112import pingofrom time import sleepboard = pingo.detect.MyBoard()led_pin = board.pins[13]led_pin.mode = pingo.OUTwhile True: led_pin.hi() sleep(1) led_pin.lo() sleep(1) 123456789101112131415class StrKeyDict0(dict): # &lt;1&gt;继承了dict def __missing__(self, key): if isinstance(key, str): # &lt;2&gt;如果找不到的键本身就是字符串，报错 raise KeyError(key) return self[str(key)] # &lt;3&gt;如果找不到的键不是字符串就把他转化成字符串再查找，self[str(key)]找不到会再次进入__missing__里 def get(self, key, default=None): try: return self[key] # &lt;4&gt;get方法吧查找工作用self[key]的形式委托给__getitem__,这样在宣布查找失败之前还能通过__missing__再给这个键一次机会 except KeyError: return default # &lt;5&gt;如果跑出error说明__missing__也失败了，返回default def __contains__(self, key): return key in self.keys() or str(key) in self.keys() # &lt;6&gt;如果用 key in my_dict会无限递归 123456789101112131415import collectionsclass StrKeyDict(collections.UserDict): # &lt;1&gt;对UserDict的扩展 def __missing__(self, key): # &lt;2&gt; # &lt;2&gt;如果找不到的键本身就是字符串，报错 if isinstance(key, str): raise KeyError(key) return self[str(key)] # &lt;3&gt;如果找不到的键不是字符串就把他转化成字符串再查找，self[str(key)]找不到会再次进入__missing__里 def __contains__(self, key): return str(key) in self.data # &lt;3&gt; def __setitem__(self, key, item): self.data[str(key)] = item # &lt;4&gt; 集合推导","categories":[{"name":"Python","slug":"Python","permalink":"http://diudiu6.com/categories/Python/"},{"name":"流畅的python","slug":"Python/流畅的python","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"第三章","slug":"Python/流畅的python/第三章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E4%B8%89%E7%AB%A0/"}],"tags":[{"name":"流畅的python","slug":"流畅的python","permalink":"http://diudiu6.com/tags/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"learning","slug":"learning","permalink":"http://diudiu6.com/tags/learning/"}]},{"title":"序列构成的数组","slug":"序列构成的数组","date":"2019-01-24T12:51:23.000Z","updated":"2020-08-26T05:46:32.000Z","comments":true,"path":"2019/01/24/序列构成的数组/","link":"","permalink":"http://diudiu6.com/2019/01/24/%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/","excerpt":"不管是python的哪种数据结构，字符串、列表、字节序列、数组、XML 元素，抑或是数据库查询结果，它们都共用一套丰富的操作：迭代、切片、排序，还有拼接。 深入理解 Python 中的不同序列类型，不但能让我们避免重新发明轮子，它们的 API 还能帮助我们把自己定义的 API 设计得跟原生的序列一样，或者是跟未来可能出现的序列类型保持兼容。","text":"不管是python的哪种数据结构，字符串、列表、字节序列、数组、XML 元素，抑或是数据库查询结果，它们都共用一套丰富的操作：迭代、切片、排序，还有拼接。 深入理解 Python 中的不同序列类型，不但能让我们避免重新发明轮子，它们的 API 还能帮助我们把自己定义的 API 设计得跟原生的序列一样，或者是跟未来可能出现的序列类型保持兼容。 容器序列（存放的是它们所包含的任意类型的对象的引用） list（列表）, tuple（元组）， collections（collections是Python内建的一个集合模块，提供了许多有用的集合类）, collections.deque（双端队列） 可以存放不同类型的数据，容器序列存放的是他们所包含的任意类型的对象的引用 扁平序列（存放的是值而不是引用，是一段连续的内存空间，更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型） str（string）, bytes（字节序列）, bytearray（字节数组）, memoryview（内存视窗）, array.array（保存相同类型的数值的动态数组） 只能容纳一种类型，存放的是值而不是引用。是一段连续的内存空间，更加经凑 可变序列 list（列表）, bytearray（字节数组）, array.array（保存相同类型的数值的动态数组）, collections.deque（双边队列）, memoryview（内存视窗） 不可变序列 tuple（元组）, str（字符串）, bytes（字节序列） 要存放1000万个浮点数时，数组（array）的效率比列表（list）高的多，因为数组在背后存在的并不是float对象，而是数字的机器翻译，也就是字节表述。如果需要频繁对序列做先进先出的操作，deque（双端队列）的速度应该会更快。如果在代码里包含操作（比如检查一个元素是否存在在一个集合里）的频率很高，用set（集合）会更合适，但他不是序列，是无序的。列表推导（列表推导是一种构建列表的方法，是构建列表（list）的快捷方式）示例 用列表推导把一个字符串变成 Unicode 码位的列表 1234&gt;&gt;&gt; symbols = &#x27;$¢£¥€¤&#x27;&gt;&gt;&gt; codes = [ord(symbol) for symbol in symbols]&gt;&gt;&gt; codes[36, 162, 163, 165, 8364, 164] map/fillter组合来创建表单 12symbols = &quot;efaevg&quot;beyond_ascii = list(fillter(lambda c: c &gt; 127, map(ord, symbols))) 列表推导 12symbols = &quot;efaevg&quot;beyond_ascii = [ord(s) for s in symbols if ord(s) &gt; 127] python会忽略代码里[],{}和()中的换行，可以省略不太好看的续行符号\\ 列表推导不会再有变量泄漏的问题列表推导、生成器表达式，以及同它们很相似的集合（set）推导和字典（dict）推导，在 Python 3 中都有了自己的局部作用域，就像函数似的。表达式内部的变量和赋值只在局部起作用，表达式的上下文里的同名变量还可以被正常引用，局部变量并不会影响到它们。 列表推导实现笛卡尔积123colors = [&quot;white&quot;, &quot;black&quot;, &quot;red&quot;]sizes = [&#x27;S&#x27;, &#x27;M&#x27;, &#x27;L&#x27;]T_shirts = [(color, size) for color in colors for size in sizes] 列表推导的作用只有一个：生成列表生成器表达式（生成器表达式可以用来创建其他任何类型的序列，具有生成各种类型的元素并用它们来填充序列的功能）虽然也可以用列表推导来初始化元组、数组或其他序列类型，但是生成器表达式是更好的选择。这是因为生成器表达式背后遵守了迭代器协议，可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。前面那种方式显然能够节省内存。 生成器表达式的语法跟列表推导差不多，只不过把方括号换成圆括号而已。 用生成器表达式初始化元组和数组123456&gt;&gt;&gt; symbols = &#x27;$¢£¥€¤&#x27;&gt;&gt;&gt; tuple(ord(symbol) for symbol in symbols) # 如果生成器表达式是一个函数调用过程中的唯一参数，那么不需要额外再用括号把它围起来。(36, 162, 163, 165, 8364, 164)&gt;&gt;&gt; import array&gt;&gt;&gt; array.array(&#x27;I&#x27;, (ord(symbol) for symbol in symbols)) #array 的构造方法需要两个参数，因此括号是必需的。array 构造方法的第一个参数指定了数组中数字的存储方式。array(&#x27;I&#x27;, [36, 162, 163, 165, 8364, 164]) 使用生成器表达式计算笛卡儿积1234567891011&gt;&gt;&gt; colors = [&#x27;black&#x27;, &#x27;white&#x27;]&gt;&gt;&gt; sizes = [&#x27;S&#x27;, &#x27;M&#x27;, &#x27;L&#x27;]&gt;&gt;&gt; for tshirt in (&#x27;%s %s&#x27; % (c, s) for c in colors for s in sizes): # 生成器表达式逐个产出元素，从来不会一次性产出一个含有 6 个 T 恤样式的列表。... print(tshirt)...black Sblack Mblack Lwhite Swhite Mwhite L 生成器表达式逐个产生元素，从来不会一次性产出一个完整的列表元组(tuple)元祖可以用于没有字段名的记录 元组不仅仅是不可变的列表，它还可以用于没有字段名的记录。元组其实是对数据的记录：元组中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置。正是这个位置信息给数据赋予了意义。如果把元组当作一些字段的集合，那么数量和位置信息就变得非常重要了如果在任何的表达式里我们在元组内对元素排序，这些元素所携带的信息就会丢失，因为这些信息是跟它们的位置有关的1234567891011121314151617&gt;&gt;&gt; lax_coordinates = (33.9425, -118.408056) &gt;&gt;&gt; city, year, pop, chg, area = (&#x27;Tokyo&#x27;, 2003, 32450, 0.66, 8014) &gt;&gt;&gt; traveler_ids = [(&#x27;USA&#x27;, &#x27;31195855&#x27;), (&#x27;BRA&#x27;, &#x27;CE342567&#x27;), ... (&#x27;ESP&#x27;, &#x27;XDA205856&#x27;)]&gt;&gt;&gt; for passport in sorted(traveler_ids): #在迭代的过程中，passport 变量被绑定到每个元组上。... print(&#x27;%s/%s&#x27; % passport) ...BRA/CE342567ESP/XDA205856USA/31195855&gt;&gt;&gt; for country, _ in traveler_ids: ... print(country)...USABRAESP for 循环可以分别提取元组里的元素，也叫作拆包（unpacking）。因为元组中第二个元素对我们没有什么用，所以它赋值给“_”占位符。拆包让元组可以完美地被当作记录来使用总结：记录与元祖——位置的重要性 元组拆包元组拆包可以应用到任何可迭代对象上，唯一的硬性要求是，被可迭代对象中的元素数量必须要跟接收这些元素的元组的空档数一致。除非我们用*来表示忽略多余的元素 *运算符把一个可迭代对象拆开作为函数的参数可以帮助我们把注意力集中在元组的部分数据中： 12345678&gt;&gt;&gt; divmod(20, 8)(2, 4)&gt;&gt;&gt; t = (20, 8)&gt;&gt;&gt; divmod(*t)(2, 4)&gt;&gt;&gt; quotient, remainder = divmod(*t)&gt;&gt;&gt; quotient, remainder(2, 4 用*来处理剩下的元素 ,在 Python 中，函数用 *args 来获取不确定数量的参数算是一种经典写法了。 123456789&gt;&gt;&gt; a, b, *rest = range(5)&gt;&gt;&gt; a, b, rest(0, 1, [2, 3, 4])&gt;&gt;&gt; a, b, *rest = range(3)&gt;&gt;&gt; a, b, rest (0, 1, [2])&gt;&gt;&gt; a, b, *rest = range(2)&gt;&gt;&gt; a, b, rest(0, 1, []) 在平行赋值中，*前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式中任意位置 123456&gt;&gt;&gt; a, *body, c, d = range(5)&gt;&gt;&gt; a, body, c, d(0, [1, 2], 3, 4)&gt;&gt;&gt; *head, b, c, d = range(5)&gt;&gt;&gt; head, b, c, d([0, 1], 2, 3, 4) 平行赋值 1b, a = a, b 下面是另一个例子，这里元组拆包的用法则是让一个函数可以用元组的形式返回多个值，然后调用函数的代码就能轻松地接受这些返回值。比如 os.path.split() 函数就会返回以路径和最后一个文件名组成的元组 (path, last_part): 1234&gt;&gt;&gt; import os&gt;&gt;&gt; _, filename = os.path.split(&#x27;/home/luciano/.ssh/idrsa.pub&#x27;)&gt;&gt;&gt; filename&#x27;idrsa.pub&#x27; 嵌套元组拆包接受表达式的元组可以是嵌套式的，例如 (a, b, (c, d))。只要这个接受元组的嵌套结构符合表达式本身的嵌套结构，Python 就可以作出正确的对应。 具名元组collections.namedtuple 是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类——这个带名字的类对调试程序有很大帮助。 实例用具名元组来记录一个城市的信息。定义和使用具名元组。 1234567891011121314151617181920212223242526&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; City = namedtuple(&#x27;City&#x27;, &#x27;name country population coordinates&#x27;) #创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。后者可以是由数个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的字符串。&gt;&gt;&gt; tokyo = City(&#x27;Tokyo&#x27;, &#x27;JP&#x27;, 36.933, (35.689722, 139.691667)) #存放在对应字段里的数据要以一串参数的形式传入到构造函数中（注意，元组的构造函数却只接受单一的可迭代对象）。&gt;&gt;&gt; tokyoCity(name=&#x27;Tokyo&#x27;, country=&#x27;JP&#x27;, population=36.933, coordinates=(35.689722,139.691667))&gt;&gt;&gt; tokyo.population #你可以通过字段名或者位置来获取一个字段的信息。36.933&gt;&gt;&gt; tokyo.coordinates(35.689722, 139.691667)&gt;&gt;&gt; tokyo[1]&#x27;JP&#x27;&gt;&gt;&gt; City._fields # _fields 属性是一个包含这个类所有字段名称的元组。(&#x27;name&#x27;, &#x27;country&#x27;, &#x27;population&#x27;, &#x27;coordinates&#x27;)&gt;&gt;&gt; LatLong = namedtuple(&#x27;LatLong&#x27;, &#x27;lat long&#x27;)&gt;&gt;&gt; delhi_data = (&#x27;Delhi NCR&#x27;, &#x27;IN&#x27;, 21.935, LatLong(28.613889, 77.208889))&gt;&gt;&gt; delhi = City._make(delhi_data) # 用 _make() 通过接受一个可迭代对象来生成这个类的一个实例，它的作用跟City(*delhi_data) 是一样的。&gt;&gt;&gt; delhi._asdict() #_asdict() 把具名元组以 collections.OrderedDict 的形式返回，我们可以利用它来把元组里的信息友好地呈现出来。OrderedDict([(&#x27;name&#x27;, &#x27;Delhi NCR&#x27;), (&#x27;country&#x27;, &#x27;IN&#x27;), (&#x27;population&#x27;,21.935), (&#x27;coordinates&#x27;, LatLong(lat=28.613889, long=77.208889))])&gt;&gt;&gt; for key, value in delhi._asdict().items(): print(key + &#x27;:&#x27;, value)name: Delhi NCRcountry: INpopulation: 21.935coordinates: LatLong(lat=28.613889, long=77.208889) 列表或元组的方法和属性（那些由object类支持的方法没有列出来） 列表 元组 s.add(s2) • • s + s2，拼接 s.iadd(s2) • s += s2，就地拼接 s.append(e) • 在尾部添加一个新元素 s.clear() • 删除所有元素 s.contains(e) • • s 是否包含 e s.copy() • 列表的浅复制 s.count(e) • • e 在 s 中出现的次数 s.delitem(p) • 把位于 p 的元素删除 s.extend(it) • 把可迭代对象 it 追加给 s s.getitem(p) • • s[p]，获取位置 p 的元素 s.getnewargs() • 在 pickle 中支持更加优化的序列化 s.index(e) • • 在 s 中找到元素 e 第一次出现的位置 s.insert(p, e) • 在位置 p 之前插入元素e s.iter() • • 获取 s 的迭代器 s.len() • • len(s)，元素的数量 s.mul(n) • • s * n，n 个 s 的重复拼接 s.imul(n) • s *= n，就地重复拼接 s.rmul(n) • • n * s，反向拼接 * s.pop([p]) • 删除最后或者是（可选的）位于 p 的元素，并返回它的值 s.remove(e) • 删除 s 中的第一次出现的 e s.reverse() • 就地把 s 的元素倒序排列 s.reversed() • 返回 s 的倒序迭代器 s.setitem(p, e) • s[p] = e，把元素 e 放在位置p，替代已经在那个位置的元素 s.sort([key],[reverse]) • 就地对 s 中的元素进行排序，可选的参数有键（key）和是否倒序（reverse） 高级切片形式的用法序列可以用 s[a:b] 的形式切片在 Python 里，像列表（list）、元组（tuple）和字符串（str）这类序列类型都支持切片操作 切片和区间会忽略最后一个元素对对象进行切片用 s[a:b:c] 的形式对 s 在 a 和 b 之间以 c 为间隔取值。c 的值还可以为负，负值意味着反向取值 1234567&gt;&gt;&gt; s = &#x27;bicycle&#x27;&gt;&gt;&gt; s[::3]&#x27;bye&#x27;&gt;&gt;&gt; s[::-1]&#x27;elcycib&#x27;&gt;&gt;&gt; s[::-2]&#x27;eccb&#x27; a:b:c 这种用法只能作为索引或者下标用在 [] 中来返回一个切片对象：slice(a, b,c) 多维切片和省略Python 内置的序列类型都是一维的，因此它们只支持单一的索引，成对出现的索引是没有用的。[] 运算符里还可以使用以逗号分开的多个索引或者是切片， 外部库 NumPy 里就用到了这个特性，二维的 numpy.ndarray 就可以用 a[i, j] 这种形式来获取，抑或是用 a[m:n,k:l] 的方式来得到二维切片。算符的话，对象的特殊方法 getitem 和 setitem 需要以元组的形式来接收a[i, j] 中的索引。也就是说，如果要得到 a[i, j] 的值，Python 会调用a.getitem((i, j))。 省略（ellipsis）的正确书写方法是三个英语句号（…），而不是 Unicdoe 码位 U+2026表示的半个省略号（…）在NumPy中 … 用作多维数组切片的快捷方式 。如果 x 是四维数组，那么 x[i, …] 就是 x[i,:, :, :] 的缩写 给切片赋值如果把切片放在赋值语句的左边，或把它作为 del 操作的对象，我们就可以对序列进行嫁接、切除或就地修改操作。 12345678910111213141516171819&gt;&gt;&gt; l = list(range(10))&gt;&gt;&gt; l[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; l[2:5] = [20, 30]&gt;&gt;&gt; l[0, 1, 20, 30, 5, 6, 7, 8, 9]&gt;&gt;&gt; del l[5:7]&gt;&gt;&gt; l[0, 1, 20, 30, 5, 8, 9]&gt;&gt;&gt; l[3::2] = [11, 22]&gt;&gt;&gt; l[0, 1, 20, 11, 5, 22, 9]&gt;&gt;&gt; l[2:5] = 100 # 如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。 正确的做法是l[2:5] = [100]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: can only assign an iterable&gt;&gt;&gt; l[2:5] = [100]&gt;&gt;&gt; l[0, 1, 100, 22, 9] 对序列使用+和*如果想要把一个序列复制几份然后再拼接起来，更快捷的做法是把这个序列乘以一个整数。同样，这个操作会产生一个新序列. 12345&gt;&gt;&gt; l = [1, 2, 3]&gt;&gt;&gt; l * 5[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]&gt;&gt;&gt; 5 * &#x27;abcd&#x27;&#x27;abcdabcdabcdabcdabcd&#x27; 和 * 都遵循这个规律，不修改原有的操作对象，而是构建一个全新的序列。 append是引用不是传值(第八章会说明引用和可变对象的原理)如果在 a * n 这个语句中，序列 a 里的元素是对其他可变对象的引用的话，你就需要格外注意了，因为这个式子的结果可能会出乎意料。比如，你想用my_list = [[]] * 3 来初始化一个由列表组成的列表，但是你得到的列表里包含的 3 个元素其实是 3 个引用，而且这 3 个引用指向的都是同一个列表。这可能不是你想要的效果。 下面错误用法 1234567a = [&#x27;_&#x27;,&#x27;_&#x27;,&#x27;_&#x27;]#或者 a=[&#x27;_&#x27;]*3board =[]for i in range(3): board.append(a)board[1][2]=&#x27;2&#x27;print(board)#board = [[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;2&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;2&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;2&#x27;]] 下面正确操作 1234board = [[&#x27;_&#x27;]*3 for i in range(3)]board[1][2]=&#x27;2&#x27;print(board)#[[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;2&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;]] 下面正确操作 1234567board =[]for i in range(3): a = [&#x27;_&#x27;,&#x27;_&#x27;,&#x27;_&#x27;]#或者 a=[&#x27;_&#x27;]*3 与上面区别，这里每次for都新建了一个列表 board.append(a)board[1][2]=&#x27;2&#x27;print(board)#[[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;2&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;]] 序列的增量赋值增量赋值运算符 += 和 *= 的表现取决于它们的第一个操作对象+= 背后的特殊方法是 iadd （用于“就地加法”）。但是如果一个类没有实现这个方法的话，Python 会退一步调用 add 。 如果 a 实现了 iadd 方法，就会调用这个方法。同时对可变序列（例如list、bytearray 和 array.array）来说，a 会就地改动，就像调用了 a.extend(b)一样。但是如果 a 没有实现 iadd 的话，a += b 这个表达式的效果就变得跟 a = a+ b 一样了：首先计算 a + b，得到一个新的对象，然后赋值给 a。也就是说，在这个表达式中，变量名会不会被关联到新的对象，完全取决于这个类型有没有实现 iadd 这个方法。总体来讲，可变序列一般都实现了 iadd 方法，因此 += 是就地加法。而不可变序列根本就不支持这个操作，对这个方法的实现也就无从谈起。上面所说的这些关于 += 的概念也适用于 *=，不同的是，后者相对应的是 imul__。关于 __iadd 和 imul 对不可变序列进行重复拼接操作的话，效率会很低，因为每次都有一个新对象，而解释器需要把原来对象中的元素先复制到新的对象里，然后再追加新的元素。str 是一个例外，因为对字符串做 += 实在是太普遍了。为 str 初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作。元组中的神奇问题12345678t=(1,2,[1,2])t*=3#也是引用拼接&gt;&gt;&gt; t[2]+=[1]#虽然报错，但依然+=成功,可以用t[2].extend([1])来避免这个异常问题&gt;&gt;&gt; Traceback (most recent call last):&gt;&gt;&gt; File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;&gt;&gt;&gt; TypeError: &#x27;tuple&#x27; object does not support item assignment&gt;&gt;&gt; t&gt;&gt;&gt; (1, 2, [1, 2, 1], 1, 2, [1, 2, 1], 1, 2, [1, 2, 1]) 教训：1.不要把可变对象放在元组里面2.增量赋值不是一个原子操作，虽然抛出异常但还是完成了3.查看python的字节码不难但有帮助 查看字节码 1234import disdis.dis(&#x27;t[2]+=[1]&#x27;)2**3 = 8 2**4 = 16 排序——list.sort方法和内置函数sorted list.sort(reverse = False, key = len) 会就地排序列表，不会把原列表复制一份。返回 None sorted(reverse = False, key = len) 会新建一个列表作为返回值 reverse 默认为 False, 如果被设为 True, 被排序的序列里的元素会以降序输出 key 一个只有一个参数的函数，这个函数会被用在序列里的每一个元素上，所产生的结果将是排序算法依赖的对比关键字。 比如在对一些字符串排序时，可以用key=str.lower 来实现忽略大小写的排序（书本36）key=len 进行基于字符串长度的排序。默认为恒值函数也就是默认用元素自己的值来排序。 用bisect来管理已排序的序列bisect 模块包含两个主要函数，bisect 和 insort，两个函数都利用二分查找算法来在有序序列中查找或插入元素。 用bisect来搜索用bisect.insort插入新元素例子haystack有序升序序列，needle需要插入的数 12345bisect.bisect(haystack, needle, lo = 0, hi = len(haystack)) #利用二分法来查找,bisect.bisect返回的位置前面的值，都小于或等于 needle 的值bisect.insort(haystack, needle) #利用二分法来插入bisect.bisect_left(haystack, needle, lo = 0, hi = len(haystack)) # 利用二分法来查找,返回位置值，前面的值都 &lt;needlebisect.bisect_right(haystack, needle, lo = 0, hi = len(haystack)) # 利用二分法来查找,返回位置值，前面的值都 ≤needle 根据一个分数找到他所对应的绩点123456import bisectdef grade(score, breakpoints=[60, 70, 80, 90], grades=&#x27;FDCBA&#x27;): i = bisect.bisect(breakpoints, score) return grades[i]print([grade(score) for score in [22, 44, 66, 77, 34, 88 , 99]])#[&#x27;F&#x27;, &#x27;F&#x27;, &#x27;D&#x27;, &#x27;C&#x27;, &#x27;F&#x27;, &#x27;B&#x27;, &#x27;A&#x27;] 数组array的使用如果只需要处理数字列表的话，数组可能是个更好的选择。如果我们需要一个只包含数字的列表，那么 array.array 比 list 更高效。数组支持所有跟可变序列有关的操作，包括 .pop、.insert 和 .extend。另外，数组还提供从文件读取和存入文件的更快的方法，如 .frombytes 和 .tofile。 创建数组需要一个类型码，这个类型码用来表示在底层的 C 语言应该存放怎样的数据类型。类型码网上都有比如 b 类型码代表的是有符号的字符（signed char），因此 array(‘b’) 创建出的数组就只能存放一个字节大小的整数，范围从 -128到 127Python 不会允许你在数组里存放除指定类型之外的数据。 一个浮点型数组的创建、存入文件和从文件读取的过程123456789101112from array import array#引入array类型from random import randomfloats = array(&#x27;d&#x27;, (random() for i in range(10**7)))#利用一个可迭代对象来建立一个双精度浮点数组（类型码是&#x27;d&#x27;)，1000万个fp = open(&#x27;floats.bin&#x27;, &#x27;wb&#x27;)floats.tofile(fp)#把数组存入一个二进制文件里fp.close()floats2 = array(&#x27;d&#x27;)#新建一个双精度浮点空数组fp = open(&#x27;floats.bin&#x27;, &#x27;rb&#x27;)floats2.frombytes(fp, 10**7)#把1000万个浮点数从二进制文件里读取出来fp.close()floats2 == floats 从 Python 3.4 开始，数组类型不再支持诸如 list.sort() 这种就地排序方法。要给数组排序的话，得用 sorted 函数新建一个数组：想要在不打乱次序的情况下为数组添加新的元素，bisect.insort 还是能派上用场 1a = array.array(a.typecode, sorted(a)) 内存视图 memoryview内存视窗能让你在不需要复制内容的前提下在数据结构之间共享内存memoryview.cast能用不同的方式读写同一块内存数据，而且内容字节不会随意移动memoryview.cast 会把同一块内存里的内容打包成一个全新的 memoryview 对象给你。 在示例里我们利用 memoryview 精准地修改了一个数组的某个字节，这个数组的元素是 16 位二进制整数。 通过改变数组中的一个字节来更新数组里某个元素的值 12345678910111213&gt;&gt;&gt; import array&gt;&gt;&gt; numbers = array.array(&#x27;h&#x27;, [-2, -1, 0, 1, 2])&gt;&gt;&gt; memv = memoryview(numbers) # 利用含有 5 个短整型有符号整数的数组（类型码是 &#x27;h&#x27;）创建一个 memoryview。&gt;&gt;&gt; len(memv)5&gt;&gt;&gt; memv[0] # memv 里的 5 个元素跟数组里的没有区别。-2&gt;&gt;&gt; memv_oct = memv.cast(&#x27;B&#x27;) # 创建一个 memv_oct，这一次是把 memv 里的内容转换成 &#x27;B&#x27; 类型，也就是无符号字符。&gt;&gt;&gt; memv_oct.tolist() # 以列表的形式查看 memv_oct 的内容。[254, 255, 255, 255, 0, 0, 1, 0, 2, 0]&gt;&gt;&gt; memv_oct[5] = 4 #把位于位置 5 的字节赋值成 4。&gt;&gt;&gt; numbersarray(&#x27;h&#x27;, [-2, -1, 1024, 1, 2]) # 因为我们把占 2 个字节的整数的高位字节改成了 4，所以这个有符号整数的值就变成了 1024。 双向队列和其他形式的队列利用 .append 和 .pop 方法，我们可以把列表当作栈或者队列来用（比如，把 .append和 .pop(0) 合起来用，就能模拟栈的“先进先出”的特点）。但是删除列表的第一个元素（抑或是在第一个元素之前添加一个元素）之类的操作是很耗时的，因为这些操作会牵扯到移动列表里的所有元素。 collections.deque 类（双向队列）是一个线程安全、可以快速从两端添加或者删除元素的数据类型。而且如果想要有一种数据类型来存放“最近用到的几个元素”，deque 也是一个很好的选择。这是因为在新建一个双向队列的时候，你可以指定这个队列的大小，如果这个队列满员了，还可以从反向端删除过期的元素，然后在尾端添加新的元素。 很多人认为python中的字典是无序的，因为它是按照hash来存储的，但是python中有个模块collections(英文，收集、集合)，里面自带了一个子类OrderedDict，实现了对字典对象中元素的排序。使用OrderedDict会根据放入元素的先后顺序进行排序OrderedDict对象的字典对象，如果其顺序不同那么Python也会把他们当做是两个不同的对象","categories":[{"name":"Python","slug":"Python","permalink":"http://diudiu6.com/categories/Python/"},{"name":"流畅的python","slug":"Python/流畅的python","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"第二章","slug":"Python/流畅的python/第二章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"}],"tags":[{"name":"流畅的python","slug":"流畅的python","permalink":"http://diudiu6.com/tags/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"learning","slug":"learning","permalink":"http://diudiu6.com/tags/learning/"}]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"http://diudiu6.com/categories/LeetCode/Medium/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"http://diudiu6.com/categories/LeetCode/Easy/"},{"name":"C++","slug":"C","permalink":"http://diudiu6.com/categories/C/"},{"name":"C++ primer plus","slug":"C/C-primer-plus","permalink":"http://diudiu6.com/categories/C/C-primer-plus/"},{"name":"第十三章","slug":"C/C-primer-plus/第十三章","permalink":"http://diudiu6.com/categories/C/C-primer-plus/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"},{"name":"Python","slug":"Python","permalink":"http://diudiu6.com/categories/Python/"},{"name":"流畅的python","slug":"Python/流畅的python","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"第九章","slug":"Python/流畅的python/第九章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"name":"深度学习","slug":"深度学习","permalink":"http://diudiu6.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"CNN","slug":"深度学习/CNN","permalink":"http://diudiu6.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CNN/"},{"name":"爬虫","slug":"爬虫","permalink":"http://diudiu6.com/categories/%E7%88%AC%E8%99%AB/"},{"name":"TensorFlow","slug":"深度学习/TensorFlow","permalink":"http://diudiu6.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow/"},{"name":"第八章","slug":"Python/流畅的python/第八章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"name":"page 搭建","slug":"page-搭建","permalink":"http://diudiu6.com/categories/page-%E6%90%AD%E5%BB%BA/"},{"name":"Markdown语法","slug":"page-搭建/Markdown语法","permalink":"http://diudiu6.com/categories/page-%E6%90%AD%E5%BB%BA/Markdown%E8%AF%AD%E6%B3%95/"},{"name":"使用技巧","slug":"使用技巧","permalink":"http://diudiu6.com/categories/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"第七章","slug":"Python/流畅的python/第七章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"name":"第五章","slug":"Python/流畅的python/第五章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E4%BA%94%E7%AB%A0/"},{"name":"第六章","slug":"Python/流畅的python/第六章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"name":"第四章","slug":"Python/流畅的python/第四章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E5%9B%9B%E7%AB%A0/"},{"name":"第三章","slug":"Python/流畅的python/第三章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"name":"第二章","slug":"Python/流畅的python/第二章","permalink":"http://diudiu6.com/categories/Python/%E6%B5%81%E7%95%85%E7%9A%84python/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://diudiu6.com/tags/LeetCode/"},{"name":"深度优先搜索 DFS","slug":"深度优先搜索-DFS","permalink":"http://diudiu6.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS/"},{"name":"回溯","slug":"回溯","permalink":"http://diudiu6.com/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"初等数学","slug":"初等数学","permalink":"http://diudiu6.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"},{"name":"hash","slug":"hash","permalink":"http://diudiu6.com/tags/hash/"},{"name":"递归","slug":"递归","permalink":"http://diudiu6.com/tags/%E9%80%92%E5%BD%92/"},{"name":"广度优先搜索 BFS","slug":"广度优先搜索-BFS","permalink":"http://diudiu6.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS/"},{"name":"learning","slug":"learning","permalink":"http://diudiu6.com/tags/learning/"},{"name":"C++ primer plus","slug":"C-primer-plus","permalink":"http://diudiu6.com/tags/C-primer-plus/"},{"name":"流畅的python","slug":"流畅的python","permalink":"http://diudiu6.com/tags/%E6%B5%81%E7%95%85%E7%9A%84python/"},{"name":"深度学习","slug":"深度学习","permalink":"http://diudiu6.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"CNN","slug":"CNN","permalink":"http://diudiu6.com/tags/CNN/"},{"name":"xpath","slug":"xpath","permalink":"http://diudiu6.com/tags/xpath/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://diudiu6.com/tags/TensorFlow/"},{"name":"Markdown语法","slug":"Markdown语法","permalink":"http://diudiu6.com/tags/Markdown%E8%AF%AD%E6%B3%95/"},{"name":"Windows","slug":"Windows","permalink":"http://diudiu6.com/tags/Windows/"}]}